{"dependencies":[{"name":"C:\\Users\\alexbol\\WebstormProjects\\flatten-js\\package.json","includedInParent":true,"mtime":1520238055570}],"generated":{"js":"\n\"use strict\";\n\nmodule.exports = function (Flatten) {\n    var Polygon = Flatten.Polygon,\n        Point = Flatten.Point,\n        Segment = Flatten.Segment,\n        Arc = Flatten.Arc,\n        Line = Flatten.Line,\n        Ray = Flatten.Ray;\n\n\n    Flatten.ray_shoot = function (polygon, point) {\n        var contains = undefined;\n\n        // if (!(polygon instanceof Polygon && point instanceof Point)) {\n        //     throw Flatten.Errors.ILLEGAL_PARAMETERS;\n        // }\n\n        // 1. Quick reject\n        if (polygon.box.notIntersect(point.box)) {\n            return Flatten.OUTSIDE;\n        }\n\n        var ray = new Ray(point);\n        var line = new Line(ray.pt, ray.norm);\n\n        // 2. Locate relevant edges of the polygon\n        var resp_edges = polygon.edges.search(ray.box);\n\n        if (resp_edges.length == 0) {\n            return Flatten.OUTSIDE;\n        }\n\n        // 3. Calculate intersections\n        var intersections = [];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = resp_edges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var edge = _step.value;\n                var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n\n                try {\n                    for (var _iterator2 = ray.intersect(edge.shape)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                        var ip = _step2.value;\n\n\n                        // If intersection is equal to query point then point lays on boundary\n                        if (ip.equalTo(point)) {\n                            return Flatten.BOUNDARY;\n                        }\n\n                        intersections.push({\n                            pt: ip,\n                            edge: edge\n                        });\n                    }\n                } catch (err) {\n                    _didIteratorError2 = true;\n                    _iteratorError2 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                            _iterator2.return();\n                        }\n                    } finally {\n                        if (_didIteratorError2) {\n                            throw _iteratorError2;\n                        }\n                    }\n                }\n            }\n\n            // 4. Sort intersection in x-ascending order\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        intersections.sort(function (i1, i2) {\n            if (Flatten.Utils.LT(i1.pt.x, i2.pt.x)) {\n                return -1;\n            }\n            if (Flatten.Utils.GT(i1.pt.x, i2.pt.x)) {\n                return 1;\n            }\n            return 0;\n        });\n\n        // 5. Count real intersections, exclude touching\n        var counter = 0;\n\n        for (var i = 0; i < intersections.length; i++) {\n            var intersection = intersections[i];\n            if (intersection.pt.equalTo(intersection.edge.shape.start)) {\n                /* skip same point between same edges if already counted */\n                if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) && intersection.edge.prev === intersections[i - 1].edge) {\n                    continue;\n                }\n                var prev_edge = intersection.edge.prev;\n                var prev_tangent = prev_edge.shape.tangentInEnd();\n                var prev_point = intersection.pt.translate(prev_tangent);\n\n                var cur_tangent = intersection.edge.shape.tangentInStart();\n                var cur_point = intersection.pt.translate(cur_tangent);\n\n                var prev_on_the_left = prev_point.leftTo(line);\n                var cur_on_the_left = cur_point.leftTo(line);\n\n                if (prev_on_the_left && !cur_on_the_left || !prev_on_the_left && cur_on_the_left) {\n                    counter++;\n                }\n            } else if (intersection.pt.equalTo(intersection.edge.shape.end)) {\n                /* skip same point between same edges if already counted */\n                if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) && intersection.edge.next === intersections[i - 1].edge) {\n                    continue;\n                }\n                var next_edge = intersection.edge.next;\n                var next_tangent = next_edge.shape.tangentInStart();\n                var next_point = intersection.pt.translate(next_tangent);\n\n                var _cur_tangent = intersection.edge.shape.tangentInEnd();\n                var _cur_point = intersection.pt.translate(_cur_tangent);\n\n                var next_on_the_left = next_point.leftTo(line);\n                var _cur_on_the_left = _cur_point.leftTo(line);\n\n                if (next_on_the_left && !_cur_on_the_left || !next_on_the_left && _cur_on_the_left) {\n                    counter++;\n                }\n            } else {\n                /* intersection point is not a coincident with a vertex */\n                if (intersection.edge.shape instanceof Segment) {\n                    counter++;\n                } else {\n                    /* Check if ray does not touch the curve in the extremal (top or bottom) point */\n                    var box = intersection.edge.shape.box;\n                    if (!(Flatten.Utils.EQ(intersection.pt.y, box.ymin) || Flatten.Utils.EQ(intersection.pt.y, box.ymax))) {\n                        counter++;\n                    }\n                }\n            }\n        }\n\n        // 6. Odd or even?\n        contains = counter % 2 == 1 ? Flatten.INSIDE : Flatten.OUTSIDE;\n\n        return contains;\n    };\n};"},"hash":"4d6d722db5e2ff4829c1dac60da3b587","cacheData":{"env":{}}}