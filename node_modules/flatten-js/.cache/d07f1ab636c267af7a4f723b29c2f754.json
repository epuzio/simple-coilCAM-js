{"dependencies":[{"name":"C:\\Users\\alexbol\\WebstormProjects\\flatten-js\\package.json","includedInParent":true,"mtime":1520238055570}],"generated":{"js":"/**\r\n * Created by Alex Bol on 3/6/2017.\r\n */\n\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nmodule.exports = function (Flatten) {\n    var Arc = Flatten.Arc,\n        vector = Flatten.vector;\n    /**\r\n     * Class representing a circle\r\n     * @type {Circle}\r\n     */\n\n    Flatten.Circle = function () {\n        /**\r\n         *\r\n         * @param {Point} pc - circle center point\r\n         * @param {number} r - circle radius\r\n         */\n        function Circle(pc, r) {\n            _classCallCheck(this, Circle);\n\n            /**\r\n             * Circle center\r\n             * @type {Point}\r\n             */\n            this.pc = pc;\n            /**\r\n             * Circle radius\r\n             * @type {number}\r\n             */\n            this.r = r;\n        }\n\n        /**\r\n         * Method clone returns new instance of a Circle\r\n         * @returns {Circle}\r\n         */\n\n\n        _createClass(Circle, [{\n            key: \"clone\",\n            value: function clone() {\n                return new Flatten.Circle(this.pc.clone(), this.r);\n            }\n\n            /**\r\n             * Circle center\r\n             * @returns {Point}\r\n             */\n\n        }, {\n            key: \"contains\",\n\n\n            /**\r\n             * Return true if circle contains point\r\n             * @param {Point} pt - test point\r\n             * @returns {boolean}\r\n             */\n            value: function contains(pt) {\n                return Flatten.Utils.LE(pt.distanceTo(this.center)[0], this.r);\n            }\n\n            /**\r\n             * Transform circle to closed arc\r\n             * @param {boolean} counterclockwise\r\n             * @returns {Arc}\r\n             */\n\n        }, {\n            key: \"toArc\",\n            value: function toArc() {\n                var counterclockwise = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n                return new Flatten.Arc(this.center, this.r, Math.PI, -Math.PI, counterclockwise);\n            }\n\n            /**\r\n             * Returns array of intersection points between circle and other shape\r\n             * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc\r\n             * @returns {Point[]}\r\n             */\n\n        }, {\n            key: \"intersect\",\n            value: function intersect(shape) {\n                if (shape instanceof Flatten.Line) {\n                    return shape.intersect(this);\n                }\n\n                if (shape instanceof Flatten.Segment) {\n                    return shape.intersect(this);\n                }\n\n                if (shape instanceof Flatten.Circle) {\n                    return Circle.intersectCirle2Circle(this, shape);\n                }\n\n                if (shape instanceof Flatten.Arc) {\n                    return shape.intersect(this);\n                }\n            }\n\n            /**\r\n             * Calculate distance and shortest segment from circle to shape and return array [distance, shortest segment]\r\n             * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n             * @returns {number} distance from circle to shape\r\n             * @returns {Segment} shortest segment between circle and shape (started at circle, ended at shape)\r\n               */\n\n        }, {\n            key: \"distanceTo\",\n            value: function distanceTo(shape) {\n                var Distance = Flatten.Distance;\n                var point2circle = Distance.point2circle,\n                    circle2circle = Distance.circle2circle,\n                    circle2line = Distance.circle2line,\n                    segment2circle = Distance.segment2circle,\n                    arc2circle = Distance.arc2circle;\n\n\n                if (shape instanceof Flatten.Point) {\n                    var _point2circle = point2circle(shape, this),\n                        _point2circle2 = _slicedToArray(_point2circle, 2),\n                        distance = _point2circle2[0],\n                        shortest_segment = _point2circle2[1];\n\n                    shortest_segment = shortest_segment.reverse();\n                    return [distance, shortest_segment];\n                }\n\n                if (shape instanceof Flatten.Circle) {\n                    var _circle2circle = circle2circle(this, shape),\n                        _circle2circle2 = _slicedToArray(_circle2circle, 2),\n                        _distance = _circle2circle2[0],\n                        _shortest_segment = _circle2circle2[1];\n\n                    return [_distance, _shortest_segment];\n                }\n\n                if (shape instanceof Flatten.Line) {\n                    var _circle2line = circle2line(this, shape),\n                        _circle2line2 = _slicedToArray(_circle2line, 2),\n                        _distance2 = _circle2line2[0],\n                        _shortest_segment2 = _circle2line2[1];\n\n                    return [_distance2, _shortest_segment2];\n                }\n\n                if (shape instanceof Flatten.Segment) {\n                    var _segment2circle = segment2circle(shape, this),\n                        _segment2circle2 = _slicedToArray(_segment2circle, 2),\n                        _distance3 = _segment2circle2[0],\n                        _shortest_segment3 = _segment2circle2[1];\n\n                    _shortest_segment3 = _shortest_segment3.reverse();\n                    return [_distance3, _shortest_segment3];\n                }\n\n                if (shape instanceof Flatten.Arc) {\n                    var _arc2circle = arc2circle(shape, this),\n                        _arc2circle2 = _slicedToArray(_arc2circle, 2),\n                        _distance4 = _arc2circle2[0],\n                        _shortest_segment4 = _arc2circle2[1];\n\n                    _shortest_segment4 = _shortest_segment4.reverse();\n                    return [_distance4, _shortest_segment4];\n                }\n\n                if (shape instanceof Flatten.Polygon) {\n                    var _Distance$shape2polyg = Distance.shape2polygon(this, shape),\n                        _Distance$shape2polyg2 = _slicedToArray(_Distance$shape2polyg, 2),\n                        _distance5 = _Distance$shape2polyg2[0],\n                        _shortest_segment5 = _Distance$shape2polyg2[1];\n\n                    return [_distance5, _shortest_segment5];\n                }\n\n                if (shape instanceof Flatten.PlanarSet) {\n                    var _Distance$shape2plana = Distance.shape2planarSet(this, shape),\n                        _Distance$shape2plana2 = _slicedToArray(_Distance$shape2plana, 2),\n                        dist = _Distance$shape2plana2[0],\n                        _shortest_segment6 = _Distance$shape2plana2[1];\n\n                    return [dist, _shortest_segment6];\n                }\n            }\n        }, {\n            key: \"svg\",\n\n\n            /**\r\n             * Return string to draw circle in svg\r\n             * @param {Object} attrs - json structure with attributes of svg circle element,\r\n             * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n             * Defaults are stroke:\"black\", strokeWidth:\"3\", fill:\"none\"\r\n             * @returns {string}\r\n             */\n            value: function svg() {\n                var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { stroke: \"black\", strokeWidth: \"3\", fill: \"none\" };\n                var stroke = attrs.stroke,\n                    strokeWidth = attrs.strokeWidth,\n                    fill = attrs.fill;\n\n                return \"\\n<circle cx=\\\"\" + this.pc.x + \"\\\" cy=\\\"\" + this.pc.y + \"\\\" r=\\\"\" + this.r + \"\\\" stroke=\\\"\" + stroke + \"\\\" stroke-width=\\\"\" + strokeWidth + \"\\\" fill=\\\"\" + fill + \"\\\" />\";\n            }\n        }, {\n            key: \"center\",\n            get: function get() {\n                return this.pc;\n            }\n\n            /**\r\n             * Circle bounding box\r\n             * @returns {Box}\r\n             */\n\n        }, {\n            key: \"box\",\n            get: function get() {\n                return new Flatten.Box(this.pc.x - this.r, this.pc.y - this.r, this.pc.x + this.r, this.pc.y + this.r);\n            }\n        }], [{\n            key: \"intersectCirle2Circle\",\n            value: function intersectCirle2Circle(circle1, circle2) {\n                var ip = [];\n\n                if (circle1.box.notIntersect(circle2.box)) {\n                    return ip;\n                }\n\n                var vec = new Flatten.Vector(circle1.pc, circle2.pc);\n\n                var r1 = circle1.r;\n                var r2 = circle2.r;\n\n                // Degenerated circle\n                if (Flatten.Utils.EQ_0(r1) || Flatten.Utils.EQ_0(r2)) return ip;\n\n                // In case of equal circles return one leftmost point\n                if (Flatten.Utils.EQ_0(vec.x) && Flatten.Utils.EQ_0(vec.y) && Flatten.Utils.EQ(r1, r2)) {\n                    ip.push(circle1.pc.translate(-r1, 0));\n                    return ip;\n                }\n\n                var dist = circle1.pc.distanceTo(circle2.pc)[0];\n\n                if (Flatten.Utils.GT(dist, r1 + r2)) // circles too far, no intersections\n                    return ip;\n\n                if (Flatten.Utils.LT(dist, Math.abs(r1 - r2))) // one circle is contained within another, no intersections\n                    return ip;\n\n                // Normalize vector.\n                vec.x /= dist;\n                vec.y /= dist;\n\n                var pt = void 0;\n\n                // Case of touching from outside or from inside - single intersection point\n                // TODO: check this specifically not sure if correct\n                if (Flatten.Utils.EQ(dist, r1 + r2) || Flatten.Utils.EQ(dist, Math.abs(r1 - r2))) {\n                    pt = circle1.pc.translate(r1 * vec.x, r1 * vec.y);\n                    ip.push(pt);\n                    return ip;\n                }\n\n                // Case of two intersection points\n\n                // Distance from first center to center of common chord:\n                //   a = (r1^2 - r2^2 + d^2) / 2d\n                // Separate for better accuracy\n                var a = r1 * r1 / (2 * dist) - r2 * r2 / (2 * dist) + dist / 2;\n\n                var mid_pt = circle1.pc.translate(a * vec.x, a * vec.y);\n                var h = Math.sqrt(r1 * r1 - a * a);\n                // let norm;\n\n                // norm = vec.rotate90CCW().multiply(h);\n                pt = mid_pt.translate(vec.rotate90CCW().multiply(h));\n                ip.push(pt);\n\n                // norm = vec.rotate90CW();\n                pt = mid_pt.translate(vec.rotate90CW().multiply(h));\n                ip.push(pt);\n\n                return ip;\n            }\n        }]);\n\n        return Circle;\n    }();\n\n    /**\r\n     * Shortcut to create new circle\r\n     * @param args\r\n     */\n    Flatten.circle = function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        return new (Function.prototype.bind.apply(Flatten.Circle, [null].concat(args)))();\n    };\n};"},"hash":"3295d2e7d5103f4be959256d8496a660","cacheData":{"env":{}}}