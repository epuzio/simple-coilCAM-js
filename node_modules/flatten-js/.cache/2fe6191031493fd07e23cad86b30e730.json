{"dependencies":[{"name":"C:\\Users\\alexbol\\WebstormProjects\\flatten-js\\package.json","includedInParent":true,"mtime":1520238055570}],"generated":{"js":"var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Created by Alex Bol on 3/17/2017.\r\n */\n\nmodule.exports = function (Flatten) {\n    /**\r\n     * Class representing an edge of polygon. Edge shape may be Segment or Arc.\r\n     * Each edge contains references to the next and previous edges in the face of the polygon.\r\n     *\r\n     * @type {Edge}\r\n     */\n    Flatten.Edge = function () {\n        /**\r\n         * Construct new instance of edge\r\n         * @param {Shape} shape Shape of type Segment of Arc\r\n         */\n        function Edge(shape) {\n            _classCallCheck(this, Edge);\n\n            /**\r\n             * Shape of the edge: Segment or Arc\r\n             */\n            this.shape = shape;\n            /**\r\n             * Pointer to the next edge in the face\r\n             */\n            this.next;\n            /**\r\n             * Pointer to the previous edge in the face\r\n             */\n            this.prev;\n            /**\r\n             * Pointer to the face containing this edge\r\n             * @type {Face}\r\n             */\n            this.face;\n            /**\r\n             * \"Arc distance\" from the face start\r\n             * @type {number}\r\n             */\n            this.arc_length = 0;\n            /**\r\n             * Start inclusion flag (inside/outside/boundary)\r\n             * @type {Boolean}\r\n             */\n            this.bvStart = undefined;\n            /**\r\n             * End inclusion flag (inside/outside/boundary)\r\n             * @type {Boolean}\r\n             */\n            this.bvEnd = undefined;\n            /**\r\n             * Edge inclusion flag (Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY)\r\n             * @type {*}\r\n             */\n            this.bv = undefined;\n            /**\r\n             * Overlap flag for boundary edge (Flatten.OVERLAP_SAME/Flatten.OVERLAP_OPPOSITE)\r\n             * @type {*}\r\n             */\n            this.overlap = undefined;\n        }\n\n        /**\r\n         * Get edge start point\r\n         */\n\n\n        _createClass(Edge, [{\n            key: \"middle\",\n\n\n            /**\r\n             * Get middle point of the edge\r\n             * @returns {Point}\r\n             */\n            value: function middle() {\n                return this.shape.middle();\n            }\n\n            /**\r\n             * Returns true if point belongs to the edge, false otherwise\r\n             * @param {Point} pt - test point\r\n             */\n\n        }, {\n            key: \"contains\",\n            value: function contains(pt) {\n                return this.shape.contains(pt);\n            }\n\n            /**\r\n             * Set inclusion flag of the edge with respect to another polygon\r\n             * Inclusion flag is one of Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY\r\n             * @param polygon\r\n             */\n\n        }, {\n            key: \"setInclusion\",\n            value: function setInclusion(polygon) {\n                if (this.bv !== undefined) return this.bv;\n\n                if (this.bvStart === undefined) {\n                    this.bvStart = Flatten.ray_shoot(polygon, this.start);\n                }\n                if (this.bvEnd === undefined) {\n                    this.bvEnd = Flatten.ray_shoot(polygon, this.end);\n                }\n                /* At least one end outside - the whole edge outside */\n                if (this.bvStart === Flatten.OUTSIDE || this.bvEnd == Flatten.OUTSIDE) {\n                    this.bv = Flatten.OUTSIDE;\n                }\n                /* At least one end inside - the whole edge inside */\n                else if (this.bvStart === Flatten.INSIDE || this.bvEnd == Flatten.INSIDE) {\n                        this.bv = Flatten.INSIDE;\n                    }\n                    /* Both are boundary - check the middle point */\n                    else {\n                            var bvMiddle = Flatten.ray_shoot(polygon, this.middle());\n                            this.bv = bvMiddle;\n                        }\n                return this.bv;\n            }\n        }, {\n            key: \"svg\",\n            value: function svg() {\n                if (this.shape instanceof Flatten.Segment) {\n                    return \" L\" + this.shape.end.x + \",\" + this.shape.end.y;\n                } else if (this.shape instanceof Flatten.Arc) {\n                    var arc = this.shape;\n                    var largeArcFlag = void 0;\n                    var sweepFlag = arc.counterClockwise ? \"1\" : \"0\";\n\n                    // Draw full circe arc as special case: split it into two half-circles\n                    if (Flatten.Utils.EQ(arc.sweep, 2 * Math.PI)) {\n                        var sign = arc.counterClockwise ? 1 : -1;\n                        var halfArc1 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle, arc.startAngle + sign * Math.PI, arc.counterClockwise);\n                        var halfArc2 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle + sign * Math.PI, arc.endAngle, arc.counterClockwise);\n\n                        largeArcFlag = \"0\";\n\n                        return \" A\" + halfArc1.r + \",\" + halfArc1.r + \" 0 \" + largeArcFlag + \",\" + sweepFlag + \" \" + halfArc1.end.x + \",\" + halfArc1.end.y + \"\\n                    A\" + halfArc2.r + \",\" + halfArc2.r + \" 0 \" + largeArcFlag + \",\" + sweepFlag + \" \" + halfArc2.end.x + \",\" + halfArc2.end.y;\n                    } else {\n                        largeArcFlag = arc.sweep <= Math.PI ? \"0\" : \"1\";\n\n                        return \" A\" + arc.r + \",\" + arc.r + \" 0 \" + largeArcFlag + \",\" + sweepFlag + \" \" + arc.end.x + \",\" + arc.end.y;\n                    }\n                }\n            }\n        }, {\n            key: \"toJSON\",\n            value: function toJSON() {\n                var json = this.shape.clone();\n                json.name = this.shape.constructor.name;\n                return json;\n            }\n        }, {\n            key: \"start\",\n            get: function get() {\n                return this.shape.start;\n            }\n\n            /**\r\n             * Get edge end point\r\n             */\n\n        }, {\n            key: \"end\",\n            get: function get() {\n                return this.shape.end;\n            }\n\n            /**\r\n             * Get edge length\r\n             */\n\n        }, {\n            key: \"length\",\n            get: function get() {\n                return this.shape.length;\n            }\n\n            /**\r\n             * Get bounding box of the edge\r\n             * @returns {Box}\r\n             */\n\n        }, {\n            key: \"box\",\n            get: function get() {\n                return this.shape.box;\n            }\n        }]);\n\n        return Edge;\n    }();\n};"},"hash":"f2715bc77d72f8d57d79c5145486b912","cacheData":{"env":{}}}