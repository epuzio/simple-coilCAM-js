{"dependencies":[{"name":"C:\\Users\\alexbol\\WebstormProjects\\flatten-js\\package.json","includedInParent":true,"mtime":1520238055570},{"name":"flatten-interval-tree","loc":{"line":9,"column":27}}],"generated":{"js":"/**\r\n * Created by Alex Bol on 3/12/2017.\r\n */\n\n\"use strict\";\n\n// require(\"babel-polyfill\");\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar IntervalTree = require('flatten-interval-tree');\n\nmodule.exports = function (Flatten) {\n    /**\r\n     * Class representing a planar set - a generic container with ability to keep and retrieve shapes and\r\n     * perform spatial queries. Planar set is an extension of Set container, so it supports\r\n     * Set properties and methods\r\n     */\n    Flatten.PlanarSet = function (_Set) {\n        _inherits(PlanarSet, _Set);\n\n        /**\r\n         * Create new empty instance of PlanarSet\r\n         */\n        function PlanarSet() {\n            _classCallCheck(this, PlanarSet);\n\n            var _this = _possibleConstructorReturn(this, (PlanarSet.__proto__ || Object.getPrototypeOf(PlanarSet)).call(this));\n\n            _this.index = new IntervalTree();\n            return _this;\n        }\n\n        /**\r\n         * Add new shape to planar set and to its spatial index.<br/>\r\n         * If shape already exist, it will not be added again.\r\n         * This happens with no error, it is possible to use <i>size</i> property to check if\r\n         * a shape was actually added.<br/>\r\n         * Method returns planar set object updated and may be chained\r\n         * @param {Shape} shape - shape to be added, should have valid <i>box</i> property\r\n         * @returns {PlanarSet}\r\n         */\n\n\n        _createClass(PlanarSet, [{\n            key: \"add\",\n            value: function add(shape) {\n                var size = this.size;\n                _get(PlanarSet.prototype.__proto__ || Object.getPrototypeOf(PlanarSet.prototype), \"add\", this).call(this, shape);\n                // size not changed - item not added, probably trying to add same item twice\n                if (this.size > size) {\n                    var node = this.index.insert(shape.box, shape);\n                }\n                return this; // in accordance to Set.add interface\n            }\n\n            /**\r\n             * Delete shape from planar set. Returns true if shape was actually deleted, false otherwise\r\n             * @param {Shape} shape - shape to be deleted\r\n             * @returns {boolean}\r\n             */\n\n        }, {\n            key: \"delete\",\n            value: function _delete(shape) {\n                var deleted = _get(PlanarSet.prototype.__proto__ || Object.getPrototypeOf(PlanarSet.prototype), \"delete\", this).call(this, shape);\n                if (deleted) {\n                    this.index.remove(shape.box, shape);\n                }\n                return deleted;\n            }\n\n            // update(shape) {\n            //     if (super.has(shape)) {\n            //         this.delete(shape);\n            //     }\n            //     this.add(shape);\n            //\n            //     return this;\n            // }\n\n        }, {\n            key: \"clear\",\n            value: function clear() {}\n\n            /**\r\n             * 2d range search in planar set.<br/>\r\n             * Returns array of all shapes in planar set which bounding box is intersected with query box\r\n             * @param {Box} box - query box\r\n             * @returns {Shapes[]}\r\n             */\n\n        }, {\n            key: \"search\",\n            value: function search(box) {\n                var resp = this.index.search(box);\n                return resp;\n            }\n\n            /**\r\n             * Point location test. Returns array of shapes which contains given point\r\n             * @param {Point} point - query point\r\n             * @returns {Array}\r\n             */\n\n        }, {\n            key: \"hit\",\n            value: function hit(point) {\n                var box = new Flatten.Box(point.x - 1, point.y - 1, point.x + 1, point.y + 1);\n                var resp = this.index.search(box);\n                return resp.filter(function (shape) {\n                    return point.on(shape);\n                });\n            }\n\n            /**\r\n             * Returns svg string to draw all shapes in planar set\r\n             * @returns {String}\r\n             */\n\n        }, {\n            key: \"svg\",\n            value: function svg() {\n                var svgcontent = [].concat(_toConsumableArray(this)).reduce(function (acc, shape) {\n                    return acc + shape.svg();\n                }, \"\");\n                return svgcontent;\n            }\n        }]);\n\n        return PlanarSet;\n    }(Set);\n};"},"hash":"e21f6dfa7919b9c7e14ed01e06ab9eb5","cacheData":{"env":{}}}