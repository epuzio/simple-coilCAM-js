{"dependencies":[{"name":"C:\\Users\\alexbol\\WebstormProjects\\flatten-js\\package.json","includedInParent":true,"mtime":1520238055570}],"generated":{"js":"\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nmodule.exports = function (Flatten) {\n    var Point = Flatten.Point,\n        Segment = Flatten.Segment,\n        Line = Flatten.Line,\n        Circle = Flatten.Circle,\n        Arc = Flatten.Arc,\n        Box = Flatten.Box,\n        Vector = Flatten.Vector;\n    /**\r\n     * Class representing a horizontal ray, used by ray shooting algorithm\r\n     * @type {Ray}\r\n     */\n\n    Flatten.Ray = function () {\n        /**\r\n         * Construct ray by setting start point\r\n         * @param {Point} pt - start point\r\n         */\n        function Ray() {\n            _classCallCheck(this, Ray);\n\n            this.pt = new Point();\n\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            if (args.length == 0) {\n                return;\n            }\n\n            if (args.length == 1 && args[0] instanceof Point) {\n                this.pt = args[0].clone();\n                return;\n            }\n\n            if (args.length == 2 && typeof args[0] == \"number\" && typeof args[1] == \"number\") {\n                this.pt = new Point(args[0], args[1]);\n                return;\n            }\n\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\n        }\n\n        /**\r\n         * Returns copied instance of the ray object\r\n         * @returns {Ray}\r\n         */\n\n\n        _createClass(Ray, [{\n            key: \"clone\",\n            value: function clone() {\n                return new Ray(this.pt);\n            }\n\n            /**\r\n             * Returns half-infinite bounding box of the ray\r\n             * @returns {Box} - bounding box\r\n             */\n\n        }, {\n            key: \"intersect\",\n\n\n            /**\r\n             * Returns array of intersection points between ray and segment or arc\r\n             * @param {Segment|Arc} - Shape to intersect with ray\r\n             * @returns {Array} array of intersection points\r\n             */\n            value: function intersect(shape) {\n                if (shape instanceof Segment) {\n                    return this.intersectRay2Segment(this, shape);\n                }\n\n                if (shape instanceof Arc) {\n                    return this.intersectRay2Arc(this, shape);\n                }\n            }\n        }, {\n            key: \"intersectRay2Segment\",\n            value: function intersectRay2Segment(ray, segment) {\n                var ip = [];\n\n                if (ray.box.notIntersect(segment.box)) {\n                    return ip;\n                }\n\n                var line = new Line(ray.start, ray.norm);\n                var ip_tmp = line.intersect(segment);\n\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = ip_tmp[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var pt = _step.value;\n\n                        if (Flatten.Utils.GE(pt.x, ray.start.x)) {\n                            ip.push(pt);\n                        }\n                    }\n\n                    /* If there were two intersection points between line and ray,\r\n                    and now there is exactly one left, it means ray starts between these points\r\n                    and there is another intersection point - start of the ray */\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n\n                if (ip_tmp.length == 2 && ip.length == 1 && ray.start.on(line)) {\n                    ip.push(ray.start);\n                }\n\n                return ip;\n            }\n        }, {\n            key: \"intersectRay2Arc\",\n            value: function intersectRay2Arc(ray, arc) {\n                var ip = [];\n\n                if (ray.box.notIntersect(arc.box)) {\n                    return ip;\n                }\n\n                var line = new Line(ray.start, ray.norm);\n                var ip_tmp = line.intersect(arc);\n\n                var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n\n                try {\n                    for (var _iterator2 = ip_tmp[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                        var pt = _step2.value;\n\n                        if (Flatten.Utils.GE(pt.x, ray.start.x)) {\n                            ip.push(pt);\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError2 = true;\n                    _iteratorError2 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                            _iterator2.return();\n                        }\n                    } finally {\n                        if (_didIteratorError2) {\n                            throw _iteratorError2;\n                        }\n                    }\n                }\n\n                return ip;\n            }\n        }, {\n            key: \"box\",\n            get: function get() {\n                return new Box(this.pt.x, this.pt.y, Number.POSITIVE_INFINITY, this.pt.y);\n            }\n\n            /**\r\n             * Return ray start point\r\n             * @returns {Point} - ray start point\r\n             */\n\n        }, {\n            key: \"start\",\n            get: function get() {\n                return this.pt;\n            }\n\n            /**\r\n             * Return ray normal vector (0,1) - horizontal ray\r\n             * @returns {Vector} - ray normal vector\r\n             */\n\n        }, {\n            key: \"norm\",\n            get: function get() {\n                return new Vector(0, 1);\n            }\n        }]);\n\n        return Ray;\n    }();\n\n    Flatten.ray = function () {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n        }\n\n        return new (Function.prototype.bind.apply(Flatten.Ray, [null].concat(args)))();\n    };\n};"},"hash":"3052934b0d8e3df26c510ef15660e18e","cacheData":{"env":{}}}