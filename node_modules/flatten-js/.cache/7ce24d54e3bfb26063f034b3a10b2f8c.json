{"dependencies":[{"name":"C:\\Users\\alexbol\\WebstormProjects\\flatten-js\\package.json","includedInParent":true,"mtime":1520238055570}],"generated":{"js":"/**\r\n * Created by Alex Bol on 2/20/2017.\r\n */\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nmodule.exports = function (Flatten) {\n    /**\r\n     * Class representing a line\r\n     * @type {Line}\r\n     */\n    Flatten.Line = function () {\n        /**\r\n         * Line may be constructed by point and normal vector or by two points that a line passes through\r\n         * @param {Point} pt - point that a line passes through\r\n         * @param {Vector|Point} norm - normal vector to a line or second point a line passes through\r\n         */\n        function Line() {\n            _classCallCheck(this, Line);\n\n            /**\r\n             * Point a line passes through\r\n             * @type {Point}\r\n             */\n            this.pt = new Flatten.Point();\n            /**\r\n             * Normal unit vector to a line\r\n             * @type {Vector}\r\n             */\n            this.norm = new Flatten.Vector(0, 1);\n\n            if (arguments.length == 0) {\n                return;\n            }\n\n            if (arguments.length == 2) {\n                var a1 = arguments.length <= 0 ? undefined : arguments[0];\n                var a2 = arguments.length <= 1 ? undefined : arguments[1];\n\n                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\n                    this.pt = a1;\n                    this.norm = Line.points2norm(a1, a2);\n                    return;\n                }\n\n                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Vector) {\n                    if (Flatten.Utils.EQ_0(a2.x) && Flatten.Utils.EQ_0(a2.y)) {\n                        throw Flatten.Errors.ILLEGAL_PARAMETERS;\n                    }\n                    this.pt = a1.clone();\n                    this.norm = a2.clone();\n                    return;\n                }\n\n                if (a1 instanceof Flatten.Vector && a2 instanceof Flatten.Point) {\n                    if (Flatten.Utils.EQ_0(a1.x) && Flatten.Utils.EQ_0(a1.y)) {\n                        throw Flatten.Errors.ILLEGAL_PARAMETERS;\n                    }\n                    this.pt = a2.clone();\n                    this.norm = a1.clone();\n                    return;\n                }\n            }\n\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\n        }\n\n        /**\r\n         * Returns cloned new instance of a line\r\n         * @returns {Line}\r\n         */\n\n\n        _createClass(Line, [{\n            key: \"clone\",\n            value: function clone() {\n                return new Flatten.Line(this.pt, this.norm);\n            }\n\n            /**\r\n             * Slope of the line - angle in radians between line and axe x from 0 to 2PI\r\n             * @returns {number} - slope of the line\r\n             */\n\n        }, {\n            key: \"parallelTo\",\n\n\n            /**\r\n             * Return true if parallel or incident to other line\r\n             * @param {Line} other_line - line to check\r\n             * @returns {boolean}\r\n             */\n            value: function parallelTo(other_line) {\n                return Flatten.Utils.EQ_0(this.norm.cross(other_line.norm));\n            }\n\n            /**\r\n             * Returns true if incident to other line\r\n             * @param {Line} other_line - line to check\r\n             * @returns {boolean}\r\n             */\n\n        }, {\n            key: \"incidentTo\",\n            value: function incidentTo(other_line) {\n                return (this.norm.equalTo(other_line.norm) || this.norm.equalTo(other_line.norm.invert())) && this.pt.on(other_line);\n            }\n\n            /**\r\n             * Returns true if point belongs to line\r\n             * @param {Point} pt Query point\r\n             * @returns {boolean}\r\n             */\n\n        }, {\n            key: \"contains\",\n            value: function contains(pt) {\n                if (this.pt.equalTo(pt)) {\n                    return true;\n                }\n                /* Line contains point if vector to point is orthogonal to the line normal vector */\n                var vec = new Flatten.Vector(this.pt, pt);\n                return Flatten.Utils.EQ_0(this.norm.dot(vec));\n            }\n\n            /**\r\n             * Returns array of intersection points\r\n             * @param {Shape} shape - shape to intersect with of the type Line, Circle, Segment, Arc\r\n             * @returns {Point[]}\r\n             */\n\n        }, {\n            key: \"intersect\",\n            value: function intersect(shape) {\n                if (shape instanceof Flatten.Line) {\n                    return Line.intersectLine2Line(this, shape);\n                }\n\n                if (shape instanceof Flatten.Circle) {\n                    return Line.intersectLine2Circle(this, shape);\n                }\n\n                if (shape instanceof Flatten.Segment) {\n                    return shape.intersect(this);\n                }\n\n                if (shape instanceof Flatten.Arc) {\n                    return Line.intersectLine2Arc(this, shape);\n                }\n            }\n\n            /**\r\n             * Calculate distance and shortest segment from line to shape and returns array [distance, shortest_segment]\r\n             * @param {Shape} shape Shape of the one of the types Point, Circle, Segment, Arc, Polygon\r\n             * @returns {Number}\r\n             * @returns {Segment}\r\n             */\n\n        }, {\n            key: \"distanceTo\",\n            value: function distanceTo(shape) {\n                var Distance = Flatten.Distance;\n\n\n                if (shape instanceof Flatten.Point) {\n                    var _Distance$point2line = Distance.point2line(shape, this),\n                        _Distance$point2line2 = _slicedToArray(_Distance$point2line, 2),\n                        distance = _Distance$point2line2[0],\n                        shortest_segment = _Distance$point2line2[1];\n\n                    shortest_segment = shortest_segment.reverse();\n                    return [distance, shortest_segment];\n                }\n\n                if (shape instanceof Flatten.Circle) {\n                    var _Distance$circle2line = Distance.circle2line(shape, this),\n                        _Distance$circle2line2 = _slicedToArray(_Distance$circle2line, 2),\n                        _distance = _Distance$circle2line2[0],\n                        _shortest_segment = _Distance$circle2line2[1];\n\n                    _shortest_segment = _shortest_segment.reverse();\n                    return [_distance, _shortest_segment];\n                }\n\n                if (shape instanceof Flatten.Segment) {\n                    var _Distance$segment2lin = Distance.segment2line(shape, this),\n                        _Distance$segment2lin2 = _slicedToArray(_Distance$segment2lin, 2),\n                        _distance2 = _Distance$segment2lin2[0],\n                        _shortest_segment2 = _Distance$segment2lin2[1];\n\n                    return [_distance2, _shortest_segment2.reverse()];\n                }\n\n                if (shape instanceof Flatten.Arc) {\n                    var _Distance$arc2line = Distance.arc2line(shape, this),\n                        _Distance$arc2line2 = _slicedToArray(_Distance$arc2line, 2),\n                        _distance3 = _Distance$arc2line2[0],\n                        _shortest_segment3 = _Distance$arc2line2[1];\n\n                    return [_distance3, _shortest_segment3.reverse()];\n                }\n\n                if (shape instanceof Flatten.Polygon) {\n                    var _Distance$shape2polyg = Distance.shape2polygon(this, shape),\n                        _Distance$shape2polyg2 = _slicedToArray(_Distance$shape2polyg, 2),\n                        _distance4 = _Distance$shape2polyg2[0],\n                        _shortest_segment4 = _Distance$shape2polyg2[1];\n\n                    return [_distance4, _shortest_segment4];\n                }\n            }\n        }, {\n            key: \"slope\",\n            get: function get() {\n                var vec = new Flatten.Vector(this.norm.y, -this.norm.x);\n                return vec.slope;\n            }\n\n            /**\r\n             * Get coefficients [A,B,C] of a standard line equation in the form Ax + By = C\r\n             * @code [A, B, C] = line.standard\r\n             * @returns {number[]} - array of coefficients\r\n             */\n\n        }, {\n            key: \"standard\",\n            get: function get() {\n                var A = this.norm.x;\n                var B = this.norm.y;\n                var C = this.norm.dot(this.pt);\n\n                return [A, B, C];\n            }\n        }], [{\n            key: \"points2norm\",\n            value: function points2norm(pt1, pt2) {\n                if (pt1.equalTo(pt2)) {\n                    throw Flatten.Errors.ILLEGAL_PARAMETERS;\n                }\n                var vec = new Flatten.Vector(pt1, pt2);\n                var unit = vec.normalize();\n                return unit.rotate90CCW();\n            }\n        }, {\n            key: \"intersectLine2Line\",\n            value: function intersectLine2Line(line1, line2) {\n                var ip = [];\n\n                var _line1$standard = _slicedToArray(line1.standard, 3),\n                    A1 = _line1$standard[0],\n                    B1 = _line1$standard[1],\n                    C1 = _line1$standard[2];\n\n                var _line2$standard = _slicedToArray(line2.standard, 3),\n                    A2 = _line2$standard[0],\n                    B2 = _line2$standard[1],\n                    C2 = _line2$standard[2];\n\n                /* Cramer's rule */\n\n\n                var det = A1 * B2 - B1 * A2;\n                var detX = C1 * B2 - B1 * C2;\n                var detY = A1 * C2 - C1 * A2;\n\n                if (!Flatten.Utils.EQ_0(det)) {\n                    var new_ip = new Flatten.Point(detX / det, detY / det);\n                    ip.push(new_ip);\n                }\n                return ip;\n            }\n        }, {\n            key: \"intersectLine2Circle\",\n            value: function intersectLine2Circle(line, circle) {\n                var ip = [];\n                var prj = circle.pc.projectionOn(line); // projection of circle center on line\n                var dist = circle.pc.distanceTo(prj)[0]; // distance from circle center to projection\n\n                if (Flatten.Utils.EQ(dist, circle.r)) {\n                    // line tangent to circle - return single intersection point\n                    ip.push(prj);\n                } else if (Flatten.Utils.LT(dist, circle.r)) {\n                    // return two intersection points\n                    var delta = Math.sqrt(circle.r * circle.r - dist * dist);\n                    var v_trans, pt;\n\n                    v_trans = line.norm.rotate90CCW().multiply(delta);\n                    pt = prj.translate(v_trans);\n                    ip.push(pt);\n\n                    v_trans = line.norm.rotate90CW().multiply(delta);\n                    pt = prj.translate(v_trans);\n                    ip.push(pt);\n                }\n                return ip;\n            }\n        }, {\n            key: \"intersectLine2Box\",\n            value: function intersectLine2Box(line, box) {\n                var pts = [new Flatten.Point(box.xmin, box.ymin), new Flatten.Point(box.xmax, box.ymin), new Flatten.Point(box.xmax, box.ymax), new Flatten.Point(box.xmin, box.ymax)];\n                var segs = [new Flatten.Segment(pts[0], pts[1]), new Flatten.Segment(pts[1], pts[2]), new Flatten.Segment(pts[2], pts[3]), new Flatten.Segment(pts[3], pts[0])];\n\n                var ips = [];\n\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = segs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var seg = _step.value;\n\n                        var ips_tmp = seg.intersect(line);\n                        var _iteratorNormalCompletion2 = true;\n                        var _didIteratorError2 = false;\n                        var _iteratorError2 = undefined;\n\n                        try {\n                            for (var _iterator2 = ips_tmp[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                                var ip = _step2.value;\n\n                                ips.push(ip);\n                            }\n                        } catch (err) {\n                            _didIteratorError2 = true;\n                            _iteratorError2 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                    _iterator2.return();\n                                }\n                            } finally {\n                                if (_didIteratorError2) {\n                                    throw _iteratorError2;\n                                }\n                            }\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n\n                ;\n                return ips;\n            }\n        }, {\n            key: \"intersectLine2Arc\",\n            value: function intersectLine2Arc(line, arc) {\n                var ip = [];\n\n                if (Line.intersectLine2Box(line, arc.box).length == 0) {\n                    return ip;\n                }\n\n                var circle = new Flatten.Circle(arc.pc, arc.r);\n                var ip_tmp = line.intersect(circle);\n                var _iteratorNormalCompletion3 = true;\n                var _didIteratorError3 = false;\n                var _iteratorError3 = undefined;\n\n                try {\n                    for (var _iterator3 = ip_tmp[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                        var pt = _step3.value;\n\n                        if (pt.on(arc)) {\n                            ip.push(pt);\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                            _iterator3.return();\n                        }\n                    } finally {\n                        if (_didIteratorError3) {\n                            throw _iteratorError3;\n                        }\n                    }\n                }\n\n                return ip;\n            }\n        }]);\n\n        return Line;\n    }();\n\n    /**\r\n     * Function to create line equivalent to \"new\" constructor\r\n     * @param args\r\n     */\n    Flatten.line = function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        return new (Function.prototype.bind.apply(Flatten.Line, [null].concat(args)))();\n    };\n};"},"hash":"0d55225dfa8009e428948d81f0df7c8a","cacheData":{"env":{}}}