{"dependencies":[{"name":"C:\\Users\\alexbol\\WebstormProjects\\flatten-js\\package.json","includedInParent":true,"mtime":1520238055570}],"generated":{"js":"var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\n\n/**\r\n *\r\n * @param Flatten\r\n */\nmodule.exports = function (Flatten) {\n    /**\r\n     *\r\n     * Class representing a point\r\n     * @type {Point}\r\n     */\n    Flatten.Point = function () {\n        /**\r\n         *\r\n         * @param {number} x - x-coordinate (float number)\r\n         * @param {number} y - y-coordinate (float number)\r\n         */\n        function Point() {\n            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n            _classCallCheck(this, Point);\n\n            /**\r\n             * x-coordinate (float number)\r\n             * @type {number}\r\n             */\n            this.x = Number.isNaN(x) ? 0 : x;\n            /**\r\n             * y-coordinate (float number)\r\n             * @type {number}\r\n             */\n            this.y = Number.isNaN(y) ? 0 : y;\n        }\n\n        /**\r\n         * Returns bounding box of a point\r\n         * @returns {Box}\r\n         */\n\n\n        _createClass(Point, [{\n            key: \"clone\",\n\n\n            /**\r\n             * Method clone returns new copied instance of point\r\n             * @returns {Point}\r\n             */\n            value: function clone() {\n                return new Flatten.Point(this.x, this.y);\n            }\n        }, {\n            key: \"equalTo\",\n\n\n            /**\r\n             * Returns true if points are equal up to [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n             * @param {Point} pt Query point\r\n             * @returns {boolean}\r\n             */\n            value: function equalTo(pt) {\n                return Flatten.Utils.EQ(this.x, pt.x) && Flatten.Utils.EQ(this.y, pt.y);\n            }\n\n            /**\r\n             * Defines predicate \"less than\" between points. Returns true if the point is less than query points, false otherwise <br/>\r\n             * By definition point1 < point2 if {point1.y < point2.y || point1.y == point2.y && point1.x < point2.y <br/>\r\n             * Numeric values compared with [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n             * @param {Point} pt Query point\r\n             * @returns {boolean}\r\n             */\n\n        }, {\n            key: \"lessThan\",\n            value: function lessThan(pt) {\n                if (Flatten.Utils.LT(this.y, pt.y)) return true;\n                if (Flatten.Utils.EQ(this.y, pt.y) && Flatten.Utils.LT(this.x, pt.x)) return true;\n                return false;\n            }\n\n            /**\r\n             * Returns new point rotated by given angle around given center point.\r\n             * If center point is omitted, rotates around zero point (0,0).\r\n             * Positive value of angle defines rotation in counter clockwise direction,\r\n             * negative angle defines rotation in clockwise clockwise direction\r\n             * @param {number} angle - angle in radians\r\n             * @param {Point} [center=(0,0)] center\r\n             * @returns {Point}\r\n             */\n\n        }, {\n            key: \"rotate\",\n            value: function rotate(angle) {\n                var center = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { x: 0, y: 0 };\n\n                var x_rot = center.x + (this.x - center.x) * Math.cos(angle) - (this.y - center.y) * Math.sin(angle);\n                var y_rot = center.y + (this.x - center.x) * Math.sin(angle) + (this.y - center.y) * Math.cos(angle);\n\n                return new Flatten.Point(x_rot, y_rot);\n            }\n\n            /**\r\n             * Returns new point translated by given vector.\r\n             * Translation vector may by also defined by a pair of numbers.\r\n             * @param {Vector} vector - Translation vector defined as Flatten.Vector or\r\n             * @param {number|number} - Translation vector defined as pair of numbers\r\n             * @returns {Point}\r\n             */\n\n        }, {\n            key: \"translate\",\n            value: function translate() {\n                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                    args[_key] = arguments[_key];\n                }\n\n                if (args.length == 1 && args[0] instanceof Flatten.Vector) {\n                    return new Flatten.Point(this.x + args[0].x, this.y + args[0].y);\n                }\n\n                if (args.length == 2 && typeof args[0] == \"number\" && typeof args[1] == \"number\") {\n                    return new Flatten.Point(this.x + args[0], this.y + args[1]);\n                }\n\n                throw Flatten.Errors.ILLEGAL_PARAMETERS;\n            }\n\n            /**\r\n             * Returns projection point on given line\r\n             * @param {Line} line Line this point be projected on\r\n             * @returns {Point}\r\n             */\n\n        }, {\n            key: \"projectionOn\",\n            value: function projectionOn(line) {\n                if (this.equalTo(line.pt)) // this point equal to line anchor point\n                    return this.clone();\n\n                var vec = new Flatten.Vector(this, line.pt);\n                if (Flatten.Utils.EQ_0(vec.cross(line.norm))) // vector to point from anchor point collinear to normal vector\n                    return line.pt.clone();\n\n                var dist = vec.dot(line.norm); // signed distance\n                var proj_vec = line.norm.multiply(dist);\n                return this.translate(proj_vec);\n            }\n\n            /**\r\n             * Returns true if point belongs to the \"left\" semi-plane, which means, point belongs to the same semi plane where line normal vector points to\r\n             * Return false if point belongs to the \"right\" semi-plane or to the line itself\r\n             * @param {Line} line Query line\r\n             * @returns {boolean}\r\n             */\n\n        }, {\n            key: \"leftTo\",\n            value: function leftTo(line) {\n                var vec = new Flatten.Vector(line.pt, this);\n                var onLeftSemiPlane = Flatten.Utils.GT(vec.dot(line.norm), 0);\n                return onLeftSemiPlane;\n            }\n\n            /**\r\n             * Calculate distance and shortest segment from point to shape and return as array [distance, shortest segment]\r\n             * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n             * @returns {number} distance from point to shape\r\n             * @returns {Segment} shortest segment between point and shape (started at point, ended at shape)\r\n             */\n\n        }, {\n            key: \"distanceTo\",\n            value: function distanceTo(shape) {\n                var Distance = Flatten.Distance;\n\n\n                if (shape instanceof Point) {\n                    var dx = shape.x - this.x;\n                    var dy = shape.y - this.y;\n                    return [Math.sqrt(dx * dx + dy * dy), new Flatten.Segment(this, shape)];\n                }\n\n                if (shape instanceof Flatten.Line) {\n                    return Distance.point2line(this, shape);\n                }\n\n                if (shape instanceof Flatten.Circle) {\n                    return Distance.point2circle(this, shape);\n                }\n\n                if (shape instanceof Flatten.Segment) {\n                    return Distance.point2segment(this, shape);\n                }\n\n                if (shape instanceof Flatten.Arc) {\n                    // let [dist, ...rest] = Distance.point2arc(this, shape);\n                    // return dist;\n                    return Distance.point2arc(this, shape);\n                }\n\n                if (shape instanceof Flatten.Polygon) {\n                    // let [dist, ...rest] = Distance.point2polygon(this, shape);\n                    // return dist;\n                    return Distance.point2polygon(this, shape);\n                }\n\n                if (shape instanceof Flatten.PlanarSet) {\n                    return Distance.shape2planarSet(this, shape);\n                }\n            }\n\n            /**\r\n             * Returns true if point is on a shape, false otherwise\r\n             * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon\r\n             * @returns {boolean}\r\n             */\n\n        }, {\n            key: \"on\",\n            value: function on(shape) {\n                if (shape instanceof Flatten.Point) {\n                    return this.equalTo(shape);\n                }\n\n                if (shape instanceof Flatten.Line) {\n                    return shape.contains(this);\n                }\n\n                if (shape instanceof Flatten.Circle) {\n                    return shape.contains(this);\n                }\n\n                if (shape instanceof Flatten.Segment) {\n                    return shape.contains(this);\n                }\n\n                if (shape instanceof Flatten.Arc) {\n                    return shape.contains(this);\n                }\n\n                if (shape instanceof Flatten.Polygon) {\n                    return shape.contains(this);\n                }\n            }\n\n            /**\r\n             * Return string to draw point in svg as circle with radius \"r\" <br/>\r\n             * Defaults attrs is an object:\r\n             * {\r\n             *    r:\"5\",\r\n             *    stroke:\"black\",\r\n             *    strokeWidth:\"1\",\r\n             *    fill:\"red\"\r\n             * }\r\n             * @param {Object} attrs - Attributes of svg circle element: \"r\", \"stroke\", \"strokeWidth\", \"fill\"\r\n             * @returns {String}\r\n             */\n\n        }, {\n            key: \"svg\",\n            value: function svg() {\n                var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { r: \"5\", stroke: \"black\", strokeWidth: \"1\", fill: \"red\" };\n                var r = attrs.r,\n                    stroke = attrs.stroke,\n                    strokeWidth = attrs.strokeWidth,\n                    fill = attrs.fill;\n\n                return \"\\n<circle cx=\\\"\" + this.x + \"\\\" cy=\\\"\" + this.y + \"\\\" r=\\\"\" + r + \"\\\" stroke=\\\"\" + stroke + \"\\\" stroke-width=\\\"\" + strokeWidth + \"\\\" fill=\\\"\" + fill + \"\\\" />\";\n            }\n        }, {\n            key: \"box\",\n            get: function get() {\n                return new Flatten.Box(this.x, this.y, this.x, this.y);\n            }\n        }, {\n            key: \"vertices\",\n            get: function get() {\n                return [this.clone()];\n            }\n        }]);\n\n        return Point;\n    }();\n\n    /**\r\n     * Function to create point equivalent to \"new\" constructor\r\n     * @param args\r\n     */\n    Flatten.point = function () {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n        }\n\n        return new (Function.prototype.bind.apply(Flatten.Point, [null].concat(args)))();\n    };\n};"},"hash":"33c690283eb1c98e956fdf1278abdf03","cacheData":{"env":{}}}