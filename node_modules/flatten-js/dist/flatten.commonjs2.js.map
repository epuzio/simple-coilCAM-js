{"version":3,"sources":["webpack://flatten/webpack/bootstrap","webpack://flatten/./algorithms/distance.js","webpack://flatten/./algorithms/ray_shooting.js","webpack://flatten/./classes/arc.js","webpack://flatten/./classes/box.js","webpack://flatten/./classes/circle.js","webpack://flatten/./classes/edge.js","webpack://flatten/./classes/face.js","webpack://flatten/./classes/line.js","webpack://flatten/./classes/matrix.js","webpack://flatten/./classes/point.js","webpack://flatten/./classes/polygon.js","webpack://flatten/./classes/ray.js","webpack://flatten/./classes/segment.js","webpack://flatten/./classes/vector.js","webpack://flatten/./data_structures/planar_set.js","webpack://flatten/./index.js","webpack://flatten/./node_modules/flatten-interval-tree/classes/interval.js","webpack://flatten/./node_modules/flatten-interval-tree/classes/node.js","webpack://flatten/./node_modules/flatten-interval-tree/index.js","webpack://flatten/./node_modules/flatten-interval-tree/utils/constants.js","webpack://flatten/./utils/errors.js","webpack://flatten/./utils/utils.js"],"names":["IntervalTree","require","module","exports","Flatten","Polygon","Point","Segment","Arc","Circle","Line","Ray","Vector","vector","Distance","pt1","pt2","distanceTo","pt","line","closest_point","projectionOn","vec","length","circle","center","dist2center","shortest_dist","Utils","EQ_0","r","toArc","start","dist","Math","abs","v","pc","normalize","multiply","translate","segment","equalTo","end","point2point","v_seg","v_ps2pt","v_pe2pt","start_sp","dot","end_sp","GE","v_unit","tangentInStart","cross","arc","dist_and_segment","shortest_segment","point2circle","on","push","sort","seg","ip","intersect","point2line","seg1","seg2","intersectSegment2Segment","point2segment","ps","pe","dist_from_start","shortest_segment_from_start","dist_from_end","shortest_segment_from_end","LT","dist_from_center","shortest_segment_from_center","dist_from_projection","shortest_segment_from_projection","point2arc","dist_tmp","segment_tmp","reverse","circle1","circle2","arc1","arc2","ip1","ip2","circle2circle","point","polygon","min_dist_and_segment","Number","POSITIVE_INFINITY","edges","edge","shape","polygon1","polygon2","edge1","edge2","box1","box2","mindist_x","max","xmin","xmax","mindist_y","ymin","ymax","mindist","box","merge","dx","dy","maxdist","level","min_stop","tree","node","box2box_minmax","item","key","value","Edge","insert","new_level_left","map","left","isNil","undefined","filter","new_level_right","right","new_level","LE","minmax_tree_process_level","set","index","root","squared_min_stop","min_dist_and_segment_new","stop","minmax_tree_calc_distance","sqrt","low","distance","PlanarSet","minmax_tree","d1","d2","GT","shape1","shape2","ray_shoot","contains","not_intersect","OUTSIDE","ray","norm","resp_edges","search","intersections","BOUNDARY","i1","i2","x","counter","i","intersection","prev","prev_edge","prev_tangent","tangentInEnd","prev_point","cur_tangent","cur_point","prev_on_the_left","leftTo","cur_on_the_left","next","next_edge","next_tangent","next_point","next_on_the_left","EQ","y","INSIDE","startAngle","endAngle","PI","counterClockwise","CCW","args","Object","name","clone","Errors","ILLEGAL_PARAMETERS","angle","slope","test_arc","sweep","cos","intersectArc2Circle","intersectArc2Arc","intersectShape2Polygon","arc2circle","arc2line","segment2arc","arc2arc","shape2polygon","shape2planarSet","func_arcs_array","angles","pts","test_arcs","prev_arc","new_arc","tangent","rotate","m","Matrix","transform","matrix","newStart","newEnd","newCenter","arcSE","f_arcs","breakToFunctional","area","reduce","acc","circularSegmentDefiniteIntegral","onLeftSide","areaTrapez","definiteIntegral","areaCircularSegment","circularSegmentArea","sin","attrs","largeArcFlag","sweepFlag","stroke","strokeWidth","fill","id","className","id_str","class_str","svg","assign","PIx2","p0","func_arcs","Box","ip_tmp","other_box","min","lessThan","high","width","height","counterclockwise","intersectCirle2Circle","circle2line","segment2circle","fillOpacity","r1","r2","a","mid_pt","h","rotate90CCW","rotate90CW","face","arc_length","bvStart","bvEnd","bv","overlap","middle","bvMiddle","flag","OVERLAP_SAME","OVERLAP_OPPOSITE","sign","halfArc1","halfArc2","toJSON","Face","first","last","_box","_orientation","Array","shapes","every","segments","points2segments","shapes2face","flattenShapes","flattenShape","add","setArcLength","Symbol","iterator","done","append","newEdge","edgeBefore","edgeAfter","delete","edge_tmp","orientation","signedArea","sArea","ORIENTATION","NOT_ORIENTABLE","CW","getSelfIntersections","svgStr","face_edges","points","exitOnFirst","int_points","resp","a1","a2","points2norm","other_line","parallelTo","intersectLine2Line","intersectLine2Circle","intersectLine2Arc","intersectLine2Polygon","segment2line","intersectLine2Box","find","A","B","C","unit","line1","line2","standard","A1","B1","C1","A2","B2","C2","det","detX","detY","new_ip","prj","delta","v_trans","segs","ips","ips_tmp","b","c","d","tx","ty","other_matrix","sx","sy","arr","x_rot","y_rot","proj_vec","onLeftSemiPlane","point2polygon","faces","size","deleted","edgeFrom","edgeTo","deleteFace","remove","isEmpty","split","addFace","rel","intersectPolygon2Polygon","valid","isSimple","newPolygon","fillRule","intersectRay2Segment","intersectRay2Arc","coords","distanceToPoint","intersectSegment2Line","intersectSegment2Circle","intersectSegment2Arc","segment2segment","rest","dy1","dy2","isZeroLength","incidentTo","scalar","ZERO_DIVISION","rpoint","norm1","norm2","atan2","n","svgcontent","Set","DP_TOL","CONTAINS","INTERLACE","f","Interval","other_interval","val1","val2","RB_TREE_COLOR_RED","RB_TREE_COLOR_BLACK","Node","parent","color","isNaN","other_node","less_than","value_equal","equal_to","maximal_val","search_node","val_less_than","nil_node","insert_node","tree_insert","recalc_max","tree_search","delete_node","tree_delete","interval","resp_nodes","tree_search_interval","forEach","output","visitor","tree_walk","callback","node_current","update_max","current_node","parent_node","insert_fixup","uncle_node","rotate_left","rotate_right","cut_node","fix_node","tree_successor","copy_data","delete_fixup","brother_node","res","not_intersect_left_subtree","not_intersect_right_subtree","node_min","node_max","node_successor","local_minimum","action","heightLeft","heightRight","testBlackHeightProperty","Error","count","ReferenceError","DECIMALS"],"mappings":"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","file":"flatten.commonjs2.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./index.js\");\n","\"use strict\";\r\n\r\nlet IntervalTree = require('flatten-interval-tree');\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Polygon, Point, Segment, Arc, Circle, Line, Ray, Vector} = Flatten;\r\n\r\n    let {vector} = Flatten;\r\n\r\n    Flatten.Distance = class Distance {\r\n        /**\r\n         * Calculate distance and shortest segment between points\r\n         * @param pt1\r\n         * @param pt2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2point(pt1, pt2) {\r\n            return pt1.distanceTo(pt2);\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and line\r\n         * @param pt\r\n         * @param line\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2line(pt, line) {\r\n            let closest_point = pt.projectionOn(line);\r\n            let vec = vector(pt, closest_point);\r\n            return [vec.length, new Segment(pt, closest_point)];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and circle\r\n         * @param pt\r\n         * @param circle\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2circle(pt, circle) {\r\n            let [dist2center, shortest_dist] = pt.distanceTo(circle.center);\r\n            if (Flatten.Utils.EQ_0(dist2center)) {\r\n                return [circle.r, new Segment(pt, circle.toArc().start)];\r\n            }\r\n            else {\r\n                let dist = Math.abs(dist2center - circle.r);\r\n                let v = vector(circle.pc, pt).normalize().multiply(circle.r);\r\n                let closest_point = circle.pc.translate(v);\r\n                return [dist, new Segment(pt, closest_point)];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and segment\r\n         * @param pt\r\n         * @param segment\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2segment(pt, segment) {\r\n            /* Degenerated case of zero-length segment */\r\n            if (segment.start.equalTo(segment.end)) {\r\n                return  Distance.point2point(pt, segment.start);\r\n            }\r\n\r\n            let v_seg = new Flatten.Vector(segment.start, segment.end);\r\n            let v_ps2pt = new Flatten.Vector(segment.start, pt);\r\n            let v_pe2pt = new Flatten.Vector(segment.end, pt);\r\n            let start_sp = v_seg.dot(v_ps2pt);\r\n            /* dot product v_seg * v_ps2pt */\r\n            let end_sp = -v_seg.dot(v_pe2pt);\r\n            /* minus dot product v_seg * v_pe2pt */\r\n\r\n            let dist;\r\n            let closest_point;\r\n            if (Flatten.Utils.GE(start_sp, 0) && Flatten.Utils.GE(end_sp, 0)) {    /* point inside segment scope */\r\n                let v_unit = segment.tangentInStart(); // new Flatten.Vector(v_seg.x / this.length, v_seg.y / this.length);\r\n                /* unit vector ||v_unit|| = 1 */\r\n                dist = Math.abs(v_unit.cross(v_ps2pt));\r\n                /* dist = abs(v_unit x v_ps2pt) */\r\n                closest_point = segment.start.translate(v_unit.multiply(v_unit.dot(v_ps2pt)));\r\n                return [dist, new Segment(pt, closest_point)];\r\n            }\r\n            else if (start_sp < 0) {                             /* point is out of scope closer to ps */\r\n                return pt.distanceTo(segment.start);\r\n            }\r\n            else {                                               /* point is out of scope closer to pe */\r\n                return pt.distanceTo(segment.end);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and arc\r\n         * @param pt\r\n         * @param arc\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2arc(pt, arc) {\r\n            let circle = new Flatten.Circle(arc.pc, arc.r);\r\n            let dist_and_segment = [];\r\n            let dist, shortest_segment;\r\n            [dist, shortest_segment] = Distance.point2circle(pt, circle);\r\n            if (shortest_segment.end.on(arc)) {\r\n                dist_and_segment.push(Distance.point2circle(pt, circle));\r\n            }\r\n            dist_and_segment.push( Distance.point2point(pt, arc.start) );\r\n            dist_and_segment.push( Distance.point2point(pt, arc.end) );\r\n\r\n            Distance.sort(dist_and_segment);\r\n\r\n            return dist_and_segment[0];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between segment and line\r\n         * @param seg\r\n         * @param line\r\n         * @returns {Number | Segment}\r\n         */\r\n        static segment2line(seg, line) {\r\n            let ip = seg.intersect(line);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0],ip[0])];   // distance = 0, closest point is the first point\r\n            }\r\n            let dist_and_segment = [];\r\n            dist_and_segment.push(Distance.point2line(seg.start, line));\r\n            dist_and_segment.push(Distance.point2line(seg.end, line));\r\n\r\n            Distance.sort( dist_and_segment );\r\n            return dist_and_segment[0];\r\n\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two segments\r\n         * @param seg1\r\n         * @param seg2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static segment2segment(seg1, seg2) {\r\n            let ip = Segment.intersectSegment2Segment(seg1, seg2);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0],ip[0])];   // distance = 0, closest point is the first point\r\n            }\r\n\r\n            // Seg1 and seg2 not intersected\r\n            let dist_and_segment = [];\r\n\r\n            dist_and_segment.push(Distance.point2segment(seg2.start, seg1));\r\n            dist_and_segment.push(Distance.point2segment(seg2.end, seg1));\r\n            dist_and_segment.push(Distance.point2segment(seg1.start, seg2));\r\n            dist_and_segment.push(Distance.point2segment(seg1.end, seg2));\r\n\r\n            Distance.sort( dist_and_segment );\r\n            return dist_and_segment[0];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between segment and circle\r\n         * @param seg\r\n         * @param circle\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static segment2circle(seg, circle) {\r\n            /* Case 1 Segment and circle intersected. Return the first point and zero distance */\r\n            let ip = seg.intersect(circle);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            // No intersection between segment and circle\r\n\r\n            /* Case 2. Distance to projection of center point to line bigger than radius\r\n             * And projection point belong to segment\r\n              * Then measure again distance from projection to circle and return it */\r\n            let line = new Flatten.Line(seg.ps, seg.pe);\r\n            let [dist, shortest_segment] = Distance.point2line(circle.center, line);\r\n            if (Flatten.Utils.GE(dist, circle.r) && shortest_segment.end.on(seg)) {\r\n                return Distance.point2circle(shortest_segment.end, circle);\r\n            }\r\n            /* Case 3. Otherwise closest point is one of the end points of the segment */\r\n            else {\r\n                let [dist_from_start, shortest_segment_from_start] = Distance.point2circle(seg.start, circle);\r\n                let [dist_from_end, shortest_segment_from_end] = Distance.point2circle(seg.end, circle);\r\n                return Flatten.Utils.LT(dist_from_start, dist_from_end) ?\r\n                    [dist_from_start, shortest_segment_from_start] :\r\n                    [dist_from_end, shortest_segment_from_end];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between segment and arc\r\n         * @param seg\r\n         * @param arc\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static segment2arc(seg, arc) {\r\n            /* Case 1 Segment and arc intersected. Return the first point and zero distance */\r\n            let ip = seg.intersect(arc);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            // No intersection between segment and arc\r\n            let line = new Flatten.Line(seg.ps, seg.pe);\r\n            let circle = new Flatten.Circle(arc.pc, arc.r);\r\n\r\n            /* Case 2. Distance to projection of center point to line bigger than radius AND\r\n             * projection point belongs to segment AND\r\n               * distance from projection point to circle belongs to arc  =>\r\n               * return this distance from projection to circle */\r\n            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n            if (Flatten.Utils.GE(dist_from_center, circle.r) && shortest_segment_from_center.end.on(seg)) {\r\n                let [dist_from_projection, shortest_segment_from_projection] =\r\n                    Distance.point2circle(shortest_segment_from_center.end, circle);\r\n                if (shortest_segment_from_projection.end.on(arc)) {\r\n                    return [dist_from_projection, shortest_segment_from_projection];\r\n                }\r\n            }\r\n            /* Case 3. Otherwise closest point is one of the end points of the segment */\r\n            let dist_and_segment = [];\r\n            dist_and_segment.push(Distance.point2arc(seg.start, arc));\r\n            dist_and_segment.push(Distance.point2arc(seg.end, arc));\r\n\r\n            let dist_tmp, segment_tmp;\r\n            [dist_tmp, segment_tmp] = Distance.point2segment(arc.start, seg);\r\n            dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2segment(arc.end, seg);\r\n            dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n\r\n            Distance.sort(dist_and_segment);\r\n            return dist_and_segment[0];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two circles\r\n         * @param circle1\r\n         * @param circle2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static circle2circle(circle1, circle2) {\r\n            let ip = circle1.intersect(circle2);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            // Case 1. Concentric circles. Convert to arcs and take distance between two arc starts\r\n            if (circle1.center.equalTo(circle2.center)) {\r\n                let arc1 = circle1.toArc();\r\n                let arc2 = circle2.toArc();\r\n                return Distance.point2point(arc1.start, arc2.start);\r\n            }\r\n            else {\r\n                // Case 2. Not concentric circles\r\n                let line = new Line(circle1.center, circle2.center);\r\n                let ip1 = line.intersect(circle1);\r\n                let ip2 = line.intersect(circle2);\r\n\r\n                let dist_and_segment = [];\r\n\r\n                dist_and_segment.push(Distance.point2point(ip1[0], ip2[0]));\r\n                dist_and_segment.push(Distance.point2point(ip1[0], ip2[1]));\r\n                dist_and_segment.push(Distance.point2point(ip1[1], ip2[0]));\r\n                dist_and_segment.push(Distance.point2point(ip1[1], ip2[1]));\r\n\r\n                Distance.sort(dist_and_segment);\r\n                return dist_and_segment[0];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two circles\r\n         * @param circle\r\n         * @param line\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static circle2line(circle, line) {\r\n            let ip = circle.intersect(line);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n            let [dist, shortest_segment] = Distance.point2circle(shortest_segment_from_center.end, circle);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between arc and line\r\n         * @param arc\r\n         * @param line\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static arc2line(arc, line) {\r\n            /* Case 1 Line and arc intersected. Return the first point and zero distance */\r\n            let ip = line.intersect(arc);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let circle = new Flatten.Circle(arc.center, arc.r);\r\n\r\n            /* Case 2. Distance to projection of center point to line bigger than radius AND\r\n             * projection point belongs to segment AND\r\n               * distance from projection point to circle belongs to arc  =>\r\n               * return this distance from projection to circle */\r\n            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n            if (Flatten.Utils.GE(dist_from_center, circle.r)) {\r\n                let [dist_from_projection, shortest_segment_from_projection] =\r\n                    Distance.point2circle(shortest_segment_from_center.end, circle);\r\n                if (shortest_segment_from_projection.end.on(arc)) {\r\n                    return [dist_from_projection, shortest_segment_from_projection];\r\n                }\r\n            }\r\n            else {\r\n                let dist_and_segment = [];\r\n                dist_and_segment.push( Distance.point2line(arc.start, line) );\r\n                dist_and_segment.push( Distance.point2line(arc.end, line) );\r\n\r\n                Distance.sort(dist_and_segment);\r\n                return dist_and_segment[0];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between arc and circle\r\n         * @param arc\r\n         * @param circle2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static arc2circle(arc, circle2) {\r\n            let ip = arc.intersect(circle2);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let circle1 = new Flatten.Circle(arc.center, arc.r);\r\n\r\n            let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\r\n            if (shortest_segment.start.on(arc)) {\r\n                return [dist, shortest_segment];\r\n            }\r\n            else {\r\n                let dist_and_segment = [];\r\n\r\n                dist_and_segment.push(Distance.point2circle(arc.start, circle2));\r\n                dist_and_segment.push(Distance.point2circle(arc.end, circle2));\r\n\r\n                Distance.sort(dist_and_segment);\r\n\r\n                return dist_and_segment[0];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two arcs\r\n         * @param arc1\r\n         * @param arc2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static arc2arc(arc1, arc2) {\r\n            let ip = arc1.intersect(arc2);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let circle1 = new Flatten.Circle(arc1.center, arc1.r);\r\n            let circle2 = new Flatten.Circle(arc2.center, arc2.r);\r\n\r\n            let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\r\n            if (shortest_segment.start.on(arc1) && shortest_segment.end.on(arc2)) {\r\n                return [dist, shortest_segment];\r\n            }\r\n            else {\r\n                let dist_and_segment = [];\r\n\r\n                let dist_tmp, segment_tmp;\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc1.start, arc2);\r\n                if (segment_tmp.end.on(arc2)) {\r\n                    dist_and_segment.push([dist_tmp, segment_tmp]);\r\n                }\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc1.end, arc2);\r\n                if (segment_tmp.end.on(arc2)) {\r\n                    dist_and_segment.push([dist_tmp, segment_tmp]);\r\n                }\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc2.start, arc1);\r\n                if (segment_tmp.end.on(arc1)) {\r\n                    dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n                }\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc2.end, arc1);\r\n                if (segment_tmp.end.on(arc1)) {\r\n                    dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n                }\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.start);\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.end);\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.start);\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.end);\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n                Distance.sort(dist_and_segment);\r\n\r\n                return dist_and_segment[0];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and polygon\r\n         * @param point\r\n         * @param polygon\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2polygon(point, polygon) {\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = (edge.shape instanceof Segment) ?\r\n                    Distance.point2segment(point, edge.shape) : Distance.point2arc(point, edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        static shape2polygon(shape, polygon) {\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = shape.distanceTo(edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n/*\r\n        static arc2polygon(arc, polygon) {\r\n            let ip = arc.intersect(polygon);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = arc.distanceTo(edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        static line2polygon(line, polygon) {\r\n            let ip = line.intersect(polygon);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = line.distanceTo(edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        static circle2polygon(circle, polygon) {\r\n            let ip = circle.intersect(polygon);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = circle.distanceTo(edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n*/\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two polygons\r\n         * @param polygon1\r\n         * @param polygon2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static polygon2polygon(polygon1, polygon2) {\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n            for (let edge1 of polygon1.edges) {\r\n                for (let edge2 of polygon2.edges) {\r\n                    let [dist, shortest_segment] = edge1.shape.distanceTo(edge2.shape);\r\n                    if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                        min_dist_and_segment = [dist, shortest_segment];\r\n                    }\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        /**\r\n         * Returns [mindist, maxdist] array of squared minimal and maximal distance between boxes\r\n         * Minimal distance by x is\r\n         *    (box2.xmin - box1.xmax), if box1 is left to box2\r\n         *    (box1.xmin - box2.xmax), if box2 is left to box1\r\n         *    0,                       if box1 and box2 are intersected by x\r\n         * Minimal distance by y is defined in the same way\r\n         *\r\n         * Maximal distance is estimated as a sum of squared dimensions of the merged box\r\n         *\r\n         * @param box1\r\n         * @param box2\r\n         * @returns {Number | Number} - minimal and maximal distance\r\n         */\r\n        static box2box_minmax(box1, box2) {\r\n            let mindist_x = Math.max( Math.max(box1.xmin - box2.xmax, 0), Math.max(box2.xmin - box1.xmax, 0) );\r\n            let mindist_y = Math.max( Math.max(box1.ymin - box2.ymax, 0), Math.max(box2.ymin - box1.ymax, 0) );\r\n            let mindist = mindist_x*mindist_x + mindist_y*mindist_y;\r\n\r\n            let box = box1.merge(box2);\r\n            let dx = box.xmax - box.xmin;\r\n            let dy = box.ymax - box.ymin;\r\n            let maxdist = dx*dx + dy*dy;\r\n\r\n            return [mindist, maxdist];\r\n        }\r\n\r\n        static minmax_tree_process_level(shape, level, min_stop, tree) {\r\n            // Calculate minmax distance to each shape in current level\r\n            // Insert result into the interval tree for further processing\r\n            // update min_stop with maxdist, it will be the new stop distance\r\n            let mindist, maxdist;\r\n            for (let node of level) {\r\n\r\n                // [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\r\n                // if (Flatten.Utils.GT(mindist, min_stop))\r\n                //     continue;\r\n\r\n                // Estimate min-max dist to the shape stored in the node.item, using node.item.key which is shape's box\r\n                [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.item.key);\r\n                if (node.item.value instanceof Flatten.Edge) {\r\n                    tree.insert([mindist, maxdist], node.item.value.shape);\r\n                }\r\n                else {\r\n                    tree.insert([mindist, maxdist], node.item.value);\r\n                }\r\n                if (Flatten.Utils.LT(maxdist, min_stop)) {\r\n                    min_stop = maxdist;                       // this will be the new distance estimation\r\n                }\r\n            }\r\n\r\n            if (level.length === 0)\r\n                return min_stop;\r\n\r\n            // Calculate new level from left and right children of the current\r\n            let new_level_left = level.map(node => node.left.isNil() ? undefined : node.left ).filter(node => node !== undefined);\r\n            let new_level_right = level.map(node => node.right.isNil() ? undefined : node.right).filter(node => node !== undefined);\r\n            // Merge left and right subtrees and leave only relevant subtrees\r\n            let new_level = [...new_level_left, ...new_level_right].filter( node => {\r\n                // Node subtree quick reject, node.max is a subtree box\r\n                let [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\r\n                return (Flatten.Utils.LE(mindist, min_stop));\r\n            });\r\n\r\n            min_stop = Distance.minmax_tree_process_level(shape, new_level, min_stop, tree);\r\n            return min_stop;\r\n        }\r\n\r\n        /**\r\n         * Calculates sorted tree of [mindist, maxdist] intervals between query shape\r\n         * and shapes of the planar set.\r\n         * @param shape\r\n         * @param set\r\n         */\r\n        static minmax_tree(shape, set, min_stop) {\r\n            let tree = new IntervalTree();\r\n            let level = [set.index.root];\r\n            let squared_min_stop = min_stop < Number.POSITIVE_INFINITY ? min_stop*min_stop : Number.POSITIVE_INFINITY;\r\n            squared_min_stop = Distance.minmax_tree_process_level(shape, level, squared_min_stop, tree);\r\n            return tree;\r\n        }\r\n\r\n        static minmax_tree_calc_distance(shape, node, min_dist_and_segment) {\r\n            let min_dist_and_segment_new, stop;\r\n            if (node != null && !node.isNil()) {\r\n                [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.left, min_dist_and_segment);\r\n\r\n                if (stop) {\r\n                    return [min_dist_and_segment_new, stop];\r\n                }\r\n\r\n                if (Flatten.Utils.LT(min_dist_and_segment_new[0], Math.sqrt(node.item.key.low))) {\r\n                    return [min_dist_and_segment_new, true];   // stop condition\r\n                }\r\n\r\n                let [dist, shortest_segment] = Distance.distance(shape, node.item.value);\r\n                // console.log(dist)\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment_new[0])) {\r\n                    min_dist_and_segment_new = [dist, shortest_segment];\r\n                }\r\n\r\n                [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.right, min_dist_and_segment_new);\r\n\r\n                return [min_dist_and_segment_new, stop];\r\n            }\r\n\r\n            return [min_dist_and_segment, false];\r\n        }\r\n\r\n        /**\r\n         * Calculates distance between shape and Planar Set of shapes\r\n         * @param shape\r\n         * @param {PlanarSet} set\r\n         * @param {Number} min_stop\r\n         * @returns {*}\r\n         */\r\n        static shape2planarSet(shape, set, min_stop = Number.POSITIVE_INFINITY) {\r\n            let min_dist_and_segment = [min_stop, new Flatten.Segment()];\r\n            let stop = false;\r\n            if (set instanceof Flatten.PlanarSet) {\r\n                let tree = Distance.minmax_tree(shape, set, min_stop);\r\n                [min_dist_and_segment, stop] = Distance.minmax_tree_calc_distance(shape, tree.root, min_dist_and_segment);\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        static sort(dist_and_segment) {\r\n            dist_and_segment.sort((d1, d2) => {\r\n                if (Flatten.Utils.LT(d1[0], d2[0])) {\r\n                    return -1;\r\n                }\r\n                if (Flatten.Utils.GT(d1[0], d2[0])) {\r\n                    return 1;\r\n                }\r\n                return 0;\r\n            });\r\n        }\r\n\r\n        static distance(shape1, shape2) {\r\n            return shape1.distanceTo(shape2);\r\n        }\r\n    }\r\n};","\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Polygon, Point, Segment, Arc, Line, Ray} = Flatten;\r\n\r\n    Flatten.ray_shoot = function(polygon, point) {\r\n        let contains = undefined;\r\n\r\n        // if (!(polygon instanceof Polygon && point instanceof Point)) {\r\n        //     throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        // }\r\n\r\n        // 1. Quick reject\r\n        if (polygon.box.not_intersect(point.box)) {\r\n            return Flatten.OUTSIDE;\r\n        }\r\n\r\n        let ray = new Ray(point);\r\n        let line = new Line(ray.pt, ray.norm);\r\n\r\n        // 2. Locate relevant edges of the polygon\r\n        let resp_edges = polygon.edges.search(ray.box);\r\n\r\n        if (resp_edges.length == 0) {\r\n            return Flatten.OUTSIDE;\r\n        }\r\n\r\n        // 3. Calculate intersections\r\n        let intersections = [];\r\n        for (let edge of resp_edges) {\r\n            for (let ip of ray.intersect(edge.shape)) {\r\n\r\n                // If intersection is equal to query point then point lays on boundary\r\n                if (ip.equalTo(point)) {\r\n                    return Flatten.BOUNDARY;\r\n                }\r\n\r\n                intersections.push({\r\n                    pt: ip,\r\n                    edge: edge\r\n                });\r\n            }\r\n        }\r\n\r\n        // 4. Sort intersection in x-ascending order\r\n        intersections.sort( (i1, i2) => {\r\n            if (Flatten.Utils.LT(i1.pt.x, i2.pt.x)) {\r\n                return -1;\r\n            }\r\n            if (Flatten.Utils.GT(i1.pt.x, i2.pt.x)) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        });\r\n\r\n        // 5. Count real intersections, exclude touching\r\n        let counter = 0;\r\n\r\n        for (let i=0; i < intersections.length; i++) {\r\n            let intersection = intersections[i];\r\n            if (intersection.pt.equalTo(intersection.edge.shape.start)) {\r\n                /* skip same point between same edges if already counted */\r\n                if (i > 0 && intersection.pt.equalTo(intersections[i-1].pt) &&\r\n                    intersection.edge.prev === intersections[i-1].edge) {\r\n                    continue;\r\n                }\r\n                let prev_edge = intersection.edge.prev;\r\n                while (Flatten.Utils.EQ_0(prev_edge.length)) {\r\n                    prev_edge = prev_edge.prev;\r\n                }\r\n                let prev_tangent = prev_edge.shape.tangentInEnd();\r\n                let prev_point = intersection.pt.translate(prev_tangent);\r\n\r\n                let cur_tangent = intersection.edge.shape.tangentInStart();\r\n                let cur_point = intersection.pt.translate(cur_tangent);\r\n\r\n                let prev_on_the_left = prev_point.leftTo(line);\r\n                let cur_on_the_left = cur_point.leftTo(line);\r\n\r\n                if ( (prev_on_the_left && !cur_on_the_left) || (!prev_on_the_left && cur_on_the_left) ) {\r\n                    counter++;\r\n                }\r\n            }\r\n            else if (intersection.pt.equalTo(intersection.edge.shape.end)) {\r\n                /* skip same point between same edges if already counted */\r\n                if (i > 0 && intersection.pt.equalTo(intersections[i-1].pt) &&\r\n                    intersection.edge.next === intersections[i-1].edge) {\r\n                    continue;\r\n                }\r\n                let next_edge = intersection.edge.next;\r\n                while (Flatten.Utils.EQ_0(next_edge.length)) {\r\n                    next_edge = next_edge.next;\r\n                }\r\n                let next_tangent = next_edge.shape.tangentInStart();\r\n                let next_point = intersection.pt.translate(next_tangent);\r\n\r\n                let cur_tangent = intersection.edge.shape.tangentInEnd();\r\n                let cur_point = intersection.pt.translate(cur_tangent);\r\n\r\n                let next_on_the_left = next_point.leftTo(line);\r\n                let cur_on_the_left = cur_point.leftTo(line);\r\n\r\n                if ( (next_on_the_left && !cur_on_the_left) || (!next_on_the_left && cur_on_the_left) ) {\r\n                    counter++;\r\n                }\r\n            }\r\n            else {        /* intersection point is not a coincident with a vertex */\r\n                if (intersection.edge.shape instanceof Segment) {\r\n                    counter++;\r\n                }\r\n                else {\r\n                    /* Check if ray does not touch the curve in the extremal (top or bottom) point */\r\n                    let box = intersection.edge.shape.box;\r\n                    if ( !(Flatten.Utils.EQ(intersection.pt.y, box.ymin) ||\r\n                            Flatten.Utils.EQ(intersection.pt.y, box.ymax)) ) {\r\n                        counter++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 6. Odd or even?\r\n        contains = counter % 2 == 1 ? Flatten.INSIDE : Flatten.OUTSIDE;\r\n\r\n        return contains;\r\n    };\r\n};","/**\r\n * Created by Alex Bol on 3/10/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing a circular arc\r\n     * @type {Arc}\r\n     */\r\n    Flatten.Arc = class Arc {\r\n        /**\r\n         *\r\n         * @param {Point} pc - arc center\r\n         * @param {number} r - arc radius\r\n         * @param {number} startAngle - start angle in radians from 0 to 2*PI\r\n         * @param {number} endAngle - end angle in radians from 0 to 2*PI\r\n         * @param {boolean} counterClockwise - arc direction, true - clockwise, false - counter clockwise\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * Arc center\r\n             * @type {Point}\r\n             */\r\n            this.pc = new Flatten.Point();\r\n            /**\r\n             * Arc radius\r\n             * @type {number}\r\n             */\r\n            this.r = 1;\r\n            /**\r\n             * Arc start angle in radians\r\n             * @type {number}\r\n             */\r\n            this.startAngle = 0;\r\n            /**\r\n             * Arc end angle in radians\r\n             * @type {number}\r\n             */\r\n            this.endAngle = 2*Math.PI;\r\n            /**\r\n             * Arc orientation\r\n             * @type {boolean}\r\n             */\r\n            this.counterClockwise = Flatten.CCW;\r\n\r\n            if (args.length == 0)\r\n                return;\r\n\r\n            if (args.length == 1 && args[0] instanceof Object && args[0].name === \"arc\") {\r\n                let {pc, r, startAngle, endAngle, counterClockwise} = args[0];\r\n                this.pc = new Flatten.Point(pc.x, pc.y);\r\n                this.r = r;\r\n                this.startAngle = startAngle;\r\n                this.endAngle = endAngle;\r\n                this.counterClockwise = counterClockwise;\r\n                return;\r\n            }\r\n            else {\r\n                let [pc, r, startAngle, endAngle, counterClockwise] = [...args];\r\n                if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\r\n                if (r !== undefined) this.r = r;\r\n                if (startAngle !== undefined) this.startAngle = startAngle;\r\n                if (endAngle!== undefined) this.endAngle = endAngle;\r\n                if (counterClockwise !== undefined) this.counterClockwise = counterClockwise;\r\n                return;\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Return new instance of arc\r\n         * @returns {Arc}\r\n         */\r\n        clone() {\r\n            return new Flatten.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);\r\n        }\r\n\r\n        /**\r\n         * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI\r\n         * @returns {number}\r\n         */\r\n        get sweep() {\r\n            if (Flatten.Utils.EQ(this.startAngle, this.endAngle))\r\n                return 0.0;\r\n            if (Flatten.Utils.EQ(Math.abs(this.startAngle - this.endAngle), Flatten.PIx2)) {\r\n                return Flatten.PIx2;\r\n            }\r\n            let sweep;\r\n            if (this.counterClockwise) {\r\n                sweep = Flatten.Utils.GT(this.endAngle, this.startAngle) ?\r\n                    this.endAngle - this.startAngle : this.endAngle - this.startAngle + Flatten.PIx2;\r\n            } else {\r\n                sweep = Flatten.Utils.GT(this.startAngle, this.endAngle) ?\r\n                    this.startAngle - this.endAngle : this.startAngle - this.endAngle + Flatten.PIx2;\r\n            }\r\n\r\n            if ( Flatten.Utils.GT(sweep, Flatten.PIx2) ) {\r\n                sweep -= Flatten.PIx2;\r\n            }\r\n            if ( Flatten.Utils.LT(sweep, 0) ) {\r\n                sweep += Flatten.PIx2;\r\n            }\r\n            return sweep;\r\n        }\r\n\r\n        /**\r\n         * Get start point of arc\r\n         * @returns {Point}\r\n         */\r\n        get start() {\r\n            let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\r\n            return p0.rotate(this.startAngle, this.pc);\r\n        }\r\n\r\n        /**\r\n         * Get end point of arc\r\n         * @returns {Point}\r\n         */\r\n        get end() {\r\n            let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\r\n            return p0.rotate(this.endAngle, this.pc);\r\n        }\r\n\r\n        /**\r\n         * Get center of arc\r\n         * @returns {Point}\r\n         */\r\n        get center() {\r\n            return this.pc.clone();\r\n        }\r\n\r\n        get vertices() {\r\n            return [this.start.clone(), this.end.clone()];\r\n        }\r\n\r\n        /**\r\n         * Get arc length\r\n         * @returns {number}\r\n         */\r\n        get length() {\r\n            return Math.abs(this.sweep*this.r);\r\n        }\r\n\r\n        /**\r\n         * Get bounding box of the arc\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            let func_arcs = this.breakToFunctional();\r\n            let box = func_arcs.reduce( (acc, arc) => acc.merge(arc.start.box), new Flatten.Box() );\r\n            box = box.merge(this.end.box);\r\n            return box;\r\n        }\r\n\r\n        /**\r\n         * Returns true if arc contains point, false otherwise\r\n         * @param {Point} pt - point to test\r\n         * @returns {boolean}\r\n         */\r\n        contains(pt) {\r\n            // first check if  point on circle (pc,r)\r\n            if (!Flatten.Utils.EQ(this.pc.distanceTo(pt)[0], this.r))\r\n                return false;\r\n\r\n            // point on circle\r\n\r\n            if (pt.equalTo(this.start))\r\n                return true;\r\n\r\n            let angle = new Flatten.Vector(this.pc, pt).slope;\r\n            let test_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);\r\n            return Flatten.Utils.LE(test_arc.length, this.length);\r\n        }\r\n\r\n        /**\r\n         * When given point belongs to arc, return array of two arcs split by this point. If points is incident\r\n         * to start or end point of the arc, return clone of the arc. If point does not belong to the arcs, return\r\n         * empty array.\r\n         * @param {Point} pt Query point\r\n         * @returns {Arc[]}\r\n         */\r\n        split(pt) {\r\n            if (!this.contains(pt))\r\n                return [];\r\n\r\n            if (Flatten.Utils.EQ_0(this.sweep))\r\n                return [this.clone()];\r\n\r\n            if (this.start.equalTo(pt) || this.end.equalTo(pt))\r\n                return [this.clone()];\r\n\r\n            let angle = new Flatten.Vector(this.pc, pt).slope;\r\n\r\n            return [\r\n                new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise),\r\n                new Flatten.Arc(this.pc, this.r, angle, this.endAngle, this.counterClockwise)\r\n            ]\r\n        }\r\n\r\n        /**\r\n         * Return middle point of the arc\r\n         * @returns {Point}\r\n         */\r\n        middle() {\r\n            let endAngle = this.counterClockwise ? this.startAngle + this.sweep/2 : this.startAngle - this.sweep/2;\r\n            let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\r\n            return arc.end;\r\n        }\r\n\r\n        /**\r\n         * Returns chord height (\"sagitta\") of the arc\r\n         * @returns {number}\r\n         */\r\n        chordHeight() {\r\n            return  (1.0 - Math.cos(Math.abs(this.sweep/2.0))) * this.r;\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points between arc and other shape\r\n         * @param {Shape} shape Shape of the one of supported types <br/>\r\n         * @returns {Points[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.contains(shape) ? [shape] : [];\r\n            }\r\n            if (shape instanceof Flatten.Line) {\r\n                return shape.intersect(this);\r\n            }\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Arc.intersectArc2Circle(this, shape);\r\n            }\r\n            if (shape instanceof Flatten.Segment) {\r\n                return shape.intersect(this);\r\n            }\r\n            if (shape instanceof Flatten.Arc) {\r\n                return Arc.intersectArc2Arc(this, shape);\r\n            }\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return Flatten.Polygon.intersectShape2Polygon(this, shape);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from arc to shape and return array [distance, shortest segment]\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n         * @returns {number} distance from arc to shape\r\n         * @returns {Segment} shortest segment between arc and shape (started at arc, ended at shape)\r\n\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [dist, shortest_segment] = Distance.point2arc(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                let [dist, shortest_segment] = Distance.arc2circle(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                let [dist, shortest_segment] = Distance.arc2line(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                let [dist, shortest_segment] = Distance.segment2arc(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                let [dist, shortest_segment] = Distance.arc2arc(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                let [dist, shortest_segment] = Distance.shape2polygon(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.PlanarSet) {\r\n                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Breaks arc in extreme point 0, pi/2, pi, 3*pi/2 and returns array of sub-arcs\r\n         * @returns {Arcs[]}\r\n         */\r\n        breakToFunctional() {\r\n            let func_arcs_array = [];\r\n            let angles = [0, Math.PI/2, 2*Math.PI/2, 3*Math.PI/2];\r\n            let pts = [\r\n                this.pc.translate(this.r,0),\r\n                this.pc.translate(0,this.r),\r\n                this.pc.translate(-this.r,0),\r\n                this.pc.translate(0,-this.r)\r\n            ];\r\n\r\n            // If arc contains extreme point,\r\n            // create test arc started at start point and ended at this extreme point\r\n            let test_arcs = [];\r\n            for (let i=0; i < 4; i++) {\r\n                if (pts[i].on(this)) {\r\n                    test_arcs.push(new Flatten.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));\r\n                }\r\n            }\r\n\r\n            if (test_arcs.length == 0) {                  // arc does contain any extreme point\r\n                func_arcs_array.push(this.clone());\r\n            }\r\n            else {                                        // arc passes extreme point\r\n                // sort these arcs by length\r\n                test_arcs.sort((arc1, arc2) => arc1.length - arc2.length);\r\n\r\n                for (let i = 0; i < test_arcs.length; i++) {\r\n                    let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\r\n                    let new_arc;\r\n                    if (prev_arc) {\r\n                        new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, test_arcs[i].endAngle, this.counterClockwise);\r\n                    }\r\n                    else {\r\n                        new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);\r\n                    }\r\n                    if (!Flatten.Utils.EQ_0(new_arc.length)) {\r\n                        func_arcs_array.push(new_arc.clone());\r\n                    }\r\n                }\r\n\r\n                // add last sub arc\r\n                let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\r\n                let new_arc;\r\n                if (prev_arc) {\r\n                    new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);\r\n                }\r\n                else {\r\n                    new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);\r\n                }\r\n                if (!Flatten.Utils.EQ_0(new_arc.length)) {\r\n                    func_arcs_array.push(new_arc.clone());\r\n                }\r\n            }\r\n            return func_arcs_array;\r\n        }\r\n\r\n        /**\r\n         * Return tangent unit vector in the start point in the direction from start to end\r\n         * @returns {Vector}\r\n         */\r\n        tangentInStart() {\r\n            let vec = new Flatten.Vector(this.pc, this.start);\r\n            let angle = this.counterClockwise ? Math.PI/2. : -Math.PI/2.;\r\n            let tangent = vec.rotate(angle).normalize();\r\n            return tangent;\r\n        }\r\n\r\n        /**\r\n         * Return tangent unit vector in the end point in the direction from end to start\r\n         * @returns {Vector}\r\n         */\r\n        tangentInEnd() {\r\n            let vec = new Flatten.Vector(this.pc, this.end);\r\n            let angle = this.counterClockwise ? -Math.PI/2. : Math.PI/2.;\r\n            let tangent = vec.rotate(angle).normalize();\r\n            return tangent;\r\n        }\r\n\r\n        /**\r\n         * Returns new arc with swapped start and end angles and reversed direction\r\n         * @returns {Arc}\r\n         */\r\n        reverse() {\r\n            return new Arc(this.pc, this.r, this.endAngle, this.startAngle, !this.counterClockwise);\r\n        }\r\n\r\n        /**\r\n         * Returns new arc translated by vector vec\r\n         * @param {Vector} vec\r\n         * @returns {Segment}\r\n         */\r\n        translate(...args) {\r\n            let arc = this.clone();\r\n            arc.pc = this.pc.translate(...args);\r\n            return arc;\r\n        }\r\n\r\n        /**\r\n         * Return new segment rotated by given angle around given point\r\n         * If point omitted, rotate around origin (0,0)\r\n         * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n         * @param {number} angle - rotation angle in radians\r\n         * @param {Point} center - center point, default is (0,0)\r\n         * @returns {Arc}\r\n         */\r\n        rotate(angle = 0, center = new Flatten.Point()) {\r\n            let m = new Flatten.Matrix();\r\n            m = m.translate(center.x, center.y).rotate(angle).translate(-center.x, -center.y);\r\n            return this.transform(m);\r\n        }\r\n\r\n        /**\r\n         * Return new arc transformed using affine transformation matrix <br/>\r\n         * Note, that non-equal scaling by x and y (matrix[0] != matrix[3]) produce illegal result\r\n         * TODO: support non-equal scaling arc to ellipse or throw exception ?\r\n         * @param {Matrix} matrix - affine transformation matrix\r\n         * @returns {Arc}\r\n         */\r\n        transform(matrix = new Flatten.Matrix()) {\r\n            let newStart = this.start.transform(matrix);\r\n            let newEnd = this.end.transform(matrix);\r\n            let newCenter = this.pc.transform(matrix);\r\n            let arc = Arc.arcSE(newCenter, newStart, newEnd, this.counterClockwise);\r\n            return arc;\r\n        }\r\n\r\n        static arcSE(center, start, end, counterClockwise) {\r\n            let {vector} = Flatten;\r\n            let startAngle = vector(center,start).slope;\r\n            let endAngle = vector(center, end).slope;\r\n            if (Flatten.Utils.EQ(startAngle, endAngle)) {\r\n                endAngle += 2*Math.PI;\r\n                counterClockwise = true;\r\n            }\r\n            let r = vector(center, start).length;\r\n\r\n            return new Arc(center, r, startAngle, endAngle, counterClockwise);\r\n        }\r\n\r\n        static intersectArc2Arc(arc1, arc2) {\r\n            var ip = [];\r\n\r\n            if (arc1.box.not_intersect(arc2.box)) {\r\n                return ip;\r\n            }\r\n\r\n            // Special case: overlapping arcs\r\n            // May return up to 4 intersection points\r\n            if (arc1.pc.equalTo(arc2.pc) && Flatten.Utils.EQ(arc1.r, arc2.r)) {\r\n                let pt;\r\n\r\n                pt = arc1.start;\r\n                if (pt.on(arc2))\r\n                    ip.push(pt);\r\n\r\n                pt = arc1.end;\r\n                if (pt.on(arc2))\r\n                    ip.push(pt);\r\n\r\n                pt = arc2.start;\r\n                if (pt.on(arc1)) ip.push(pt);\r\n\r\n                pt = arc2.end;\r\n                if (pt.on(arc1)) ip.push(pt);\r\n\r\n                return ip;\r\n            }\r\n\r\n            // Common case\r\n            let circle1 = new Flatten.Circle(arc1.pc, arc1.r);\r\n            let circle2 = new Flatten.Circle(arc2.pc, arc2.r);\r\n            let ip_tmp =  circle1.intersect(circle2);\r\n            for (let pt of ip_tmp) {\r\n                if (pt.on(arc1) && pt.on(arc2)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n            return ip;\r\n        }\r\n\r\n        static intersectArc2Circle(arc, circle) {\r\n            let ip = [];\r\n\r\n            if (arc.box.not_intersect(circle.box)) {\r\n                return ip;\r\n            }\r\n\r\n            // Case when arc center incident to circle center\r\n            // Return arc's end points as 2 intersection points\r\n            if (circle.pc.equalTo(arc.pc) && Flatten.Utils.EQ(circle.r, arc.r)) {\r\n                ip.push(arc.start);\r\n                ip.push(arc.end);\r\n                return ip;\r\n            }\r\n\r\n            // Common case\r\n            let circle1 = circle;\r\n            let circle2 = new Flatten.Circle(arc.pc, arc.r);\r\n            let ip_tmp = circle1.intersect(circle2);\r\n            for (let pt of ip_tmp) {\r\n                if (pt.on(arc)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n            return ip;\r\n        }\r\n\r\n        definiteIntegral(ymin=0) {\r\n            let f_arcs = this.breakToFunctional();\r\n            let area = f_arcs.reduce( (acc, arc) => acc + arc.circularSegmentDefiniteIntegral(ymin), 0.0 );\r\n            return area;\r\n        }\r\n\r\n        circularSegmentDefiniteIntegral(ymin) {\r\n            let line = new Flatten.Line(this.start, this.end);\r\n            let onLeftSide = this.pc.leftTo(line);\r\n            let segment = new Flatten.Segment(this.start, this.end);\r\n            let areaTrapez = segment.definiteIntegral(ymin);\r\n            let areaCircularSegment = this.circularSegmentArea();\r\n            let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;\r\n            return area;\r\n        }\r\n\r\n        circularSegmentArea() {\r\n            return (0.5*this.r*this.r*(this.sweep - Math.sin(this.sweep)))\r\n        }\r\n\r\n        /**\r\n         * Return string to draw arc in svg\r\n         * @param {Object} attrs - an object with attributes of svg path element,\r\n         * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let largeArcFlag = this.sweep <= Math.PI ? \"0\" : \"1\";\r\n            let sweepFlag = this.counterClockwise ? \"1\" : \"0\";\r\n            let {stroke, strokeWidth, fill, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n            if (Flatten.Utils.EQ(this.sweep, 2*Math.PI)) {\r\n                let circle = new Flatten.Circle(this.pc, this.r);\r\n                return circle.svg(attrs);\r\n            }\r\n            else {\r\n                return `\\n<path d=\"M${this.start.x},${this.start.y}\r\n                             A${this.r},${this.r} 0 ${largeArcFlag},${sweepFlag} ${this.end.x},${this.end.y}\"\r\n                    stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" ${id_str} ${class_str} />`\r\n            }\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"arc\"});\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Function to create arc equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.arc = (...args) => new Flatten.Arc(...args);\r\n};","/**\r\n * Created by Alex Bol on 3/7/2017.\r\n */\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class Box represent bounding box of the shape\r\n     * @type {Box}\r\n     */\r\n    Flatten.Box = class Box {\r\n        /**\r\n         *\r\n         * @param {number} xmin - minimal x coordinate\r\n         * @param {number} ymin - minimal y coordinate\r\n         * @param {number} xmax - maximal x coordinate\r\n         * @param {number} ymax - maximal y coordinate\r\n         */\r\n        constructor(xmin=undefined, ymin=undefined, xmax=undefined, ymax=undefined) {\r\n            /**\r\n             * Minimal x coordinate\r\n             * @type {number}\r\n             */\r\n            this.xmin = xmin;\r\n            /**\r\n             * Minimal y coordinate\r\n             * @type {number}\r\n             */\r\n            this.ymin = ymin;\r\n            /**\r\n             * Maximal x coordinate\r\n             * @type {number}\r\n             */\r\n            this.xmax = xmax;\r\n            /**\r\n             * Maximal y coordinate\r\n             * @type {number}\r\n             */\r\n            this.ymax = ymax;\r\n        }\r\n\r\n        /**\r\n         * Clones and returns new instance of box\r\n         * @returns {Box}\r\n         */\r\n        clone() {\r\n            return new Box(this.xmin, this.ymin, this.xmax, this.ymax);\r\n        }\r\n\r\n        /**\r\n         * Property low need for interval tree interface\r\n         * @returns {Point}\r\n         */\r\n        get low() {\r\n            return new Flatten.Point(this.xmin, this.ymin);\r\n        }\r\n\r\n        /**\r\n         * Property high need for interval tree interface\r\n         * @returns {Point}\r\n         */\r\n        get high() {\r\n            return new Flatten.Point(this.xmax, this.ymax);\r\n        }\r\n\r\n        /**\r\n         * Property max returns the box itself !\r\n         * @returns {Box}\r\n         */\r\n        get max() {\r\n            return this.clone();\r\n        }\r\n\r\n        /**\r\n         * Return center of the box\r\n         * @returns {Point}\r\n         */\r\n        get center() {\r\n            return new Flatten.Point( (this.xmin + this.xmax)/2, (this.ymin + this.ymax)/2 );\r\n        }\r\n\r\n        /**\r\n         * Returns true if not intersected with other box\r\n         * @param {Box} other_box - other box to test\r\n         * @returns {boolean}\r\n         */\r\n        not_intersect(other_box) {\r\n            return (\r\n                this.xmax < other_box.xmin ||\r\n                this.xmin > other_box.xmax ||\r\n                this.ymax < other_box.ymin ||\r\n                this.ymin > other_box.ymax\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Returns true if intersected with other box\r\n         * @param {Box} other_box - Query box\r\n         * @returns {boolean}\r\n         */\r\n        intersect(other_box) {\r\n            return !this.not_intersect(other_box);\r\n        }\r\n\r\n        /**\r\n         * Returns new box merged with other box\r\n         * @param {Box} other_box - Other box to merge with\r\n         * @returns {Box}\r\n         */\r\n        merge(other_box) {\r\n            return new Box(\r\n                this.xmin === undefined ? other_box.xmin : Math.min(this.xmin, other_box.xmin),\r\n                this.ymin === undefined ? other_box.ymin : Math.min(this.ymin, other_box.ymin),\r\n                this.xmax === undefined ? other_box.xmax : Math.max(this.xmax, other_box.xmax),\r\n                this.ymax === undefined ? other_box.ymax : Math.max(this.ymax, other_box.ymax)\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Defines predicate \"less than\" between two boxes. Need for interval index\r\n         * @param {Box} other_box - other box\r\n         * @returns {boolean} - true if this box less than other box, false otherwise\r\n         */\r\n        less_than(other_box) {\r\n            if (this.low.lessThan(other_box.low))\r\n                return true;\r\n            if (this.low.equalTo(other_box.low) && this.high.lessThan(other_box.high))\r\n                return true;\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Returns true if this box is equal to other box, false otherwise\r\n         * @param {Box} other_box - query box\r\n         * @returns {boolean}\r\n         */\r\n        equal_to(other_box) {\r\n            return (this.low.equalTo(other_box.low) && this.high.equalTo(other_box.high));\r\n        }\r\n\r\n        output() {\r\n            return this.clone();\r\n        }\r\n\r\n        maximal_val(box1, box2) {\r\n            // return pt1.lessThan(pt2) ? pt2.clone() : pt1.clone();\r\n            return box1.merge(box2);\r\n        }\r\n\r\n        val_less_than(pt1, pt2) {\r\n            return pt1.lessThan(pt2);\r\n        }\r\n\r\n        /**\r\n         * Set new values to the box object\r\n         * @param {number} xmin - miminal x coordinate\r\n         * @param {number} ymin - minimal y coordinate\r\n         * @param {number} xmax - maximal x coordinate\r\n         * @param {number} ymax - maximal y coordinate\r\n         */\r\n        set(xmin, ymin, xmax, ymax) {\r\n            this.xmin = xmin;\r\n            this.ymin = ymin;\r\n            this.xmax = xmax;\r\n            this.ymax = ymax;\r\n        }\r\n\r\n        /**\r\n         * Return string to draw circle in svg\r\n         * @param {Object} attrs - an object with attributes of svg rectangle element,\r\n         * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {stroke, strokeWidth, fill, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n            let width = this.xmax - this.xmin;\r\n            let height = this.ymax - this.ymin;\r\n\r\n            return `\\n<rect x=\"${this.xmin}\" y=\"${this.ymin}\" width=${width} height=${height} stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" ${id_str} ${class_str} />`;\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Shortcut to create new circle\r\n     * @param args\r\n     * @returns {Box}\r\n     */\r\n    Flatten.box = (...args) => new Flatten.Box(...args);\r\n\r\n};\r\n","/**\r\n * Created by Alex Bol on 3/6/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Arc,vector} = Flatten;\r\n    /**\r\n     * Class representing a circle\r\n     * @type {Circle}\r\n     */\r\n    Flatten.Circle = class Circle {\r\n        /**\r\n         *\r\n         * @param {Point} pc - circle center point\r\n         * @param {number} r - circle radius\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * Circle center\r\n             * @type {Point}\r\n             */\r\n            this.pc = new Flatten.Point();\r\n            /**\r\n             * Circle radius\r\n             * @type {number}\r\n             */\r\n            this.r = 1;\r\n\r\n            if (args.length == 1 && args[0] instanceof Object && args[0].name === \"circle\") {\r\n                let {pc, r} = args[0];\r\n                this.pc = new Flatten.Point(pc);\r\n                this.r = r;\r\n                return;\r\n            }\r\n            else {\r\n                let [pc, r] = [...args];\r\n                if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\r\n                if (r !== undefined) this.r = r;\r\n                return;\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Method clone returns new instance of a Circle\r\n         * @returns {Circle}\r\n         */\r\n        clone() {\r\n            return new Flatten.Circle(this.pc.clone(), this.r);\r\n        }\r\n\r\n        /**\r\n         * Circle center\r\n         * @returns {Point}\r\n         */\r\n        get center() {\r\n            return this.pc;\r\n        }\r\n\r\n        /**\r\n         * Circle bounding box\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return new Flatten.Box(\r\n                this.pc.x - this.r,\r\n                this.pc.y - this.r,\r\n                this.pc.x + this.r,\r\n                this.pc.y + this.r\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Return true if circle contains point\r\n         * @param {Point} pt - test point\r\n         * @returns {boolean}\r\n         */\r\n        contains(pt) {\r\n            return Flatten.Utils.LE(pt.distanceTo(this.center)[0], this.r);\r\n        }\r\n\r\n        /**\r\n         * Transform circle to closed arc\r\n         * @param {boolean} counterclockwise\r\n         * @returns {Arc}\r\n         */\r\n        toArc(counterclockwise=true) {\r\n            return new Flatten.Arc(this.center, this.r, Math.PI, -Math.PI, counterclockwise);\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points between circle and other shape\r\n         * @param {Shape} shape Shape of the one of supported types\r\n         * @returns {Point[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.contains(shape) ? [shape] : [];\r\n            }\r\n            if (shape instanceof Flatten.Line) {\r\n                return shape.intersect(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                return shape.intersect(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Circle.intersectCirle2Circle(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                return shape.intersect(this);\r\n            }\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return Flatten.Polygon.intersectShape2Polygon(this, shape);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from circle to shape and return array [distance, shortest segment]\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n         * @returns {number} distance from circle to shape\r\n         * @returns {Segment} shortest segment between circle and shape (started at circle, ended at shape)\r\n\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n            let {point2circle, circle2circle, circle2line, segment2circle, arc2circle} = Distance;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [distance, shortest_segment] = point2circle(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                let [distance, shortest_segment] = circle2circle(this, shape);\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                let [distance, shortest_segment] = circle2line(this, shape);\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                let [distance, shortest_segment] = segment2circle(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                let [distance, shortest_segment] = arc2circle(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                let [distance, shortest_segment] = Distance.shape2polygon(this, shape);\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.PlanarSet) {\r\n                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n        }\r\n\r\n        static intersectCirle2Circle(circle1, circle2) {\r\n            let ip = [];\r\n\r\n            if (circle1.box.not_intersect(circle2.box)) {\r\n                return ip;\r\n            }\r\n\r\n            let vec = new Flatten.Vector(circle1.pc, circle2.pc);\r\n\r\n            let r1 = circle1.r;\r\n            let r2 = circle2.r;\r\n\r\n            // Degenerated circle\r\n            if (Flatten.Utils.EQ_0(r1) || Flatten.Utils.EQ_0(r2))\r\n                return ip;\r\n\r\n            // In case of equal circles return one leftmost point\r\n            if (Flatten.Utils.EQ_0(vec.x) && Flatten.Utils.EQ_0(vec.y) && Flatten.Utils.EQ(r1, r2)) {\r\n                ip.push(circle1.pc.translate(-r1, 0));\r\n                return ip;\r\n            }\r\n\r\n            let dist = circle1.pc.distanceTo(circle2.pc)[0];\r\n\r\n            if (Flatten.Utils.GT(dist, r1 + r2))               // circles too far, no intersections\r\n                return ip;\r\n\r\n            if (Flatten.Utils.LT(dist, Math.abs(r1 - r2)))     // one circle is contained within another, no intersections\r\n                return ip;\r\n\r\n            // Normalize vector.\r\n            vec.x /= dist;\r\n            vec.y /= dist;\r\n\r\n            let pt;\r\n\r\n            // Case of touching from outside or from inside - single intersection point\r\n            // TODO: check this specifically not sure if correct\r\n            if (Flatten.Utils.EQ(dist, r1 + r2) || Flatten.Utils.EQ(dist, Math.abs(r1 - r2))) {\r\n                pt = circle1.pc.translate(r1*vec.x, r1*vec.y);\r\n                ip.push(pt);\r\n                return ip;\r\n            }\r\n\r\n            // Case of two intersection points\r\n\r\n            // Distance from first center to center of common chord:\r\n            //   a = (r1^2 - r2^2 + d^2) / 2d\r\n            // Separate for better accuracy\r\n            let a = (r1*r1)/(2*dist) - (r2*r2)/(2*dist) + dist/2;\r\n\r\n            let mid_pt = circle1.pc.translate(a*vec.x, a*vec.y);\r\n            let h = Math.sqrt(r1*r1 - a*a);\r\n            // let norm;\r\n\r\n            // norm = vec.rotate90CCW().multiply(h);\r\n            pt = mid_pt.translate(vec.rotate90CCW().multiply(h));\r\n            ip.push(pt);\r\n\r\n            // norm = vec.rotate90CW();\r\n            pt = mid_pt.translate(vec.rotate90CW().multiply(h));\r\n            ip.push(pt);\r\n\r\n            return ip;\r\n        }\r\n\r\n        /**\r\n         * Return string to draw circle in svg\r\n         * @param {Object} attrs - an object with attributes of svg circle element,\r\n         * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {stroke, strokeWidth, fill, fillOpacity, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n            return `\\n<circle cx=\"${this.pc.x}\" cy=\"${this.pc.y}\" r=\"${this.r}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} />`;\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"circle\"});\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Shortcut to create new circle\r\n     * @param args\r\n     */\r\n    Flatten.circle = (...args) => new Flatten.Circle(...args);\r\n};","/**\r\n * Created by Alex Bol on 3/17/2017.\r\n */\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing an edge of polygon. Edge shape may be Segment or Arc.\r\n     * Each edge contains references to the next and previous edges in the face of the polygon.\r\n     *\r\n     * @type {Edge}\r\n     */\r\n    Flatten.Edge = class Edge {\r\n        /**\r\n         * Construct new instance of edge\r\n         * @param {Shape} shape Shape of type Segment of Arc\r\n         */\r\n        constructor(shape) {\r\n            /**\r\n             * Shape of the edge: Segment or Arc\r\n             */\r\n            this.shape = shape;\r\n            /**\r\n             * Pointer to the next edge in the face\r\n             */\r\n            this.next;\r\n            /**\r\n             * Pointer to the previous edge in the face\r\n             */\r\n            this.prev;\r\n            /**\r\n             * Pointer to the face containing this edge\r\n             * @type {Face}\r\n             */\r\n            this.face;\r\n            /**\r\n             * \"Arc distance\" from the face start\r\n             * @type {number}\r\n             */\r\n            this.arc_length = 0;\r\n            /**\r\n             * Start inclusion flag (inside/outside/boundary)\r\n             * @type {Boolean}\r\n             */\r\n            this.bvStart = undefined;\r\n            /**\r\n             * End inclusion flag (inside/outside/boundary)\r\n             * @type {Boolean}\r\n             */\r\n            this.bvEnd = undefined;\r\n            /**\r\n             * Edge inclusion flag (Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY)\r\n             * @type {*}\r\n             */\r\n            this.bv = undefined;\r\n            /**\r\n             * Overlap flag for boundary edge (Flatten.OVERLAP_SAME/Flatten.OVERLAP_OPPOSITE)\r\n             * @type {*}\r\n             */\r\n            this.overlap = undefined;\r\n        }\r\n\r\n        /**\r\n         * Get edge start point\r\n         */\r\n        get start() {\r\n            return this.shape.start;\r\n        }\r\n\r\n        /**\r\n         * Get edge end point\r\n         */\r\n        get end() {\r\n            return this.shape.end;\r\n        }\r\n\r\n        /**\r\n         * Get edge length\r\n         */\r\n        get length() {\r\n            return this.shape.length;\r\n        }\r\n\r\n        /**\r\n         * Get bounding box of the edge\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return this.shape.box;\r\n        }\r\n\r\n        isSegment() {\r\n            return this.shape instanceof Flatten.Segment;\r\n        }\r\n\r\n        isArc() {\r\n            return this.shape instanceof Flatten.Arc;\r\n        }\r\n        /**\r\n         * Get middle point of the edge\r\n         * @returns {Point}\r\n         */\r\n        middle() {\r\n            return this.shape.middle();\r\n        }\r\n\r\n        /**\r\n         * Returns true if point belongs to the edge, false otherwise\r\n         * @param {Point} pt - test point\r\n         */\r\n        contains(pt) {\r\n            return this.shape.contains(pt);\r\n        }\r\n\r\n        /**\r\n         * Set inclusion flag of the edge with respect to another polygon\r\n         * Inclusion flag is one of Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY\r\n         * @param polygon\r\n         */\r\n        setInclusion(polygon) {\r\n            if (this.bv !== undefined) return this.bv;\r\n\r\n            if (this.bvStart === undefined) {\r\n                this.bvStart = Flatten.ray_shoot(polygon, this.start);\r\n            }\r\n            if (this.bvEnd === undefined) {\r\n                this.bvEnd = Flatten.ray_shoot(polygon, this.end);\r\n            }\r\n            /* At least one end outside - the whole edge outside */\r\n            if (this.bvStart === Flatten.OUTSIDE || this.bvEnd == Flatten.OUTSIDE) {\r\n                this.bv = Flatten.OUTSIDE;\r\n            }\r\n            /* At least one end inside - the whole edge inside */\r\n            else if (this.bvStart === Flatten.INSIDE || this.bvEnd == Flatten.INSIDE) {\r\n                this.bv = Flatten.INSIDE;\r\n            }\r\n            /* Both are boundary - check the middle point */\r\n            else {\r\n                let bvMiddle = Flatten.ray_shoot(polygon, this.middle());\r\n                this.bv = bvMiddle;\r\n            }\r\n            return this.bv;\r\n        }\r\n\r\n        /**\r\n         * Set overlapping between two coincident boundary edges\r\n         * Overlapping flag is one of Flatten.OVERLAP_SAME or Flatten.OVERLAP_OPPOSITE\r\n         * @param edge\r\n         */\r\n        setOverlap(edge) {\r\n            let flag = undefined;\r\n            let shape1 = this.shape;\r\n            let shape2 = edge.shape;\r\n\r\n            if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Segment) {\r\n                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end)) {\r\n                    flag = Flatten.OVERLAP_SAME;\r\n                }\r\n                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start)) {\r\n                    flag = Flatten.OVERLAP_OPPOSITE;\r\n                }\r\n            }\r\n            else if (shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Arc) {\r\n                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && /*shape1.counterClockwise === shape2.counterClockwise &&*/\r\n                    shape1.middle().equalTo(shape2.middle())) {\r\n                    flag = Flatten.OVERLAP_SAME;\r\n                }\r\n                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && /*shape1.counterClockwise !== shape2.counterClockwise &&*/\r\n                    shape1.middle().equalTo(shape2.middle())) {\r\n                    flag = Flatten.OVERLAP_OPPOSITE;\r\n                }\r\n            }\r\n            else if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Arc ||\r\n                shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Segment) {\r\n                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.middle().equalTo(shape2.middle())) {\r\n                    flag = Flatten.OVERLAP_SAME;\r\n                }\r\n                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.middle().equalTo(shape2.middle())) {\r\n                    flag = Flatten.OVERLAP_OPPOSITE;\r\n                }\r\n            }\r\n\r\n            /* Do not update overlap flag if already set on previous chain */\r\n            if (this.overlap === undefined) this.overlap = flag;\r\n            if (edge.overlap === undefined) edge.overlap = flag;\r\n        }\r\n\r\n        svg() {\r\n            if (this.shape instanceof Flatten.Segment) {\r\n                return ` L${this.shape.end.x},${this.shape.end.y}`;\r\n            }\r\n            else if (this.shape instanceof  Flatten.Arc) {\r\n                let arc = this.shape;\r\n                let largeArcFlag;\r\n                let sweepFlag = arc.counterClockwise ? \"1\" : \"0\";\r\n\r\n                // Draw full circe arc as special case: split it into two half-circles\r\n                if (Flatten.Utils.EQ(arc.sweep, 2*Math.PI)) {\r\n                    let sign = arc.counterClockwise ? 1 : -1;\r\n                    let halfArc1 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle, arc.startAngle + sign*Math.PI, arc.counterClockwise);\r\n                    let halfArc2 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle + sign*Math.PI, arc.endAngle, arc.counterClockwise);\r\n\r\n                    largeArcFlag = \"0\";\r\n\r\n                    return ` A${halfArc1.r},${halfArc1.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc1.end.x},${halfArc1.end.y}\r\n                    A${halfArc2.r},${halfArc2.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc2.end.x},${halfArc2.end.y}`\r\n                }\r\n                else {\r\n                    largeArcFlag = arc.sweep <= Math.PI ? \"0\" : \"1\";\r\n\r\n                    return ` A${arc.r},${arc.r} 0 ${largeArcFlag},${sweepFlag} ${arc.end.x},${arc.end.y}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        toJSON() {\r\n            return this.shape.toJSON();\r\n        }\r\n    };\r\n};","/**\r\n * Created by Alex Bol on 3/17/2017.\r\n */\r\n\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function (Flatten) {\r\n    let {Point, point, Segment, segment, Arc, Box, Edge, Circle} = Flatten;\r\n\r\n    /**\r\n     * Class representing a face (closed loop) in a [polygon]{@link Flatten.Polygon} object.\r\n     * Face is a circular bidirectional linked list of [edges]{@link Flatten.Edge}.\r\n     * Face object cannot be instantiated with a constructor.\r\n     * Instead, use [polygon.addFace()]{@link Flatten.Polygon#addFace} method.\r\n     * <br/>\r\n     * Note, that face only set entry point to the linked list of edges but does not contain edges by itself.\r\n     * Container of edges is a property of the polygon object. <br/>\r\n     *\r\n     * @example\r\n     * // Face implements \"next\" iterator which enables to iterate edges in for loop:\r\n     * for (let edge of face) {\r\n     *      console.log(edge.shape.length)     // do something\r\n     * }\r\n     *\r\n     * // Instead, it is possible to iterate edges as linked list, starting from face.first:\r\n     * let edge = face.first;\r\n     * do {\r\n     *   console.log(edge.shape.length);   // do something\r\n     *   edge = edge.next;\r\n     * } while (edge != face.first)\r\n     */\r\n    Flatten.Face = class Face {\r\n        constructor(polygon, ...args) {\r\n            /**\r\n             * Reference to the first edge in face\r\n             */\r\n            this.first;\r\n            /**\r\n             * Reference to the last edge in face\r\n             */\r\n            this.last;\r\n\r\n            this._box = undefined;  // new Box();\r\n            this._orientation = undefined;\r\n\r\n            if (args.length == 0) {\r\n                return;\r\n            }\r\n\r\n            /* If passed an array it supposed to be:\r\n             1) array of shapes that performs close loop or\r\n             2) array of points that performs set of vertices\r\n             */\r\n            if (args.length == 1) {\r\n                if (args[0] instanceof Array) {\r\n                    // let argsArray = args[0];\r\n                    let shapes = args[0];  // argsArray[0];\r\n                    if (shapes.length == 0)\r\n                        return;\r\n\r\n                    if (shapes.every((shape) => {\r\n                            return shape instanceof Point\r\n                        })) {\r\n                        let segments = Face.points2segments(shapes);\r\n                        this.shapes2face(polygon.edges, segments);\r\n                    }\r\n                    else if (shapes.every((shape) => {\r\n                            return (shape instanceof Segment || shape instanceof Arc)\r\n                        })) {\r\n                        this.shapes2face(polygon.edges, shapes);\r\n                    }\r\n                    // this is from JSON.parse object\r\n                    else if (shapes.every((shape) => {\r\n                            return (shape.name === \"segment\" || shape.name === \"arc\")\r\n                        })) {\r\n                        let flattenShapes = [];\r\n                        for (let shape of shapes) {\r\n                            let flattenShape;\r\n                            if (shape.name === \"segment\") {\r\n                                flattenShape = new Segment(shape);\r\n                            }\r\n                            else {\r\n                                flattenShape = new Arc(shape);\r\n                            }\r\n                            flattenShapes.push(flattenShape);\r\n                        }\r\n                        this.shapes2face(polygon.edges, flattenShapes);\r\n                    }\r\n                }\r\n                /* Create new face and copy edges into polygon.edges set */\r\n                else if (args[0] instanceof Face) {\r\n                    let face = args[0];\r\n                    this.first = face.first;\r\n                    this.last = face.last;\r\n                    for (let edge of face) {\r\n                        polygon.edges.add(edge);\r\n                    }\r\n                }\r\n                /* Instantiate face from circle circle in CCW orientation */\r\n                else if (args[0] instanceof Circle) {\r\n                    this.shapes2face(polygon.edges, [args[0].toArc(Flatten.CCW)]);\r\n                }\r\n                /* Instantiate face from a box in CCW orientation */\r\n                else if (args[0] instanceof Box) {\r\n                    let box = args[0];\r\n                    this.shapes2face(polygon.edges, [\r\n                        segment(point(box.xmin, box.ymin), point(box.xmax, box.ymin)),\r\n                        segment(point(box.xmax, box.ymin), point(box.xmax, box.ymax)),\r\n                        segment(point(box.xmax, box.ymax), point(box.xmin, box.ymax)),\r\n                        segment(point(box.xmin, box.ymax), point(box.xmin, box.ymin))\r\n                    ]);\r\n                }\r\n            }\r\n            /* If passed two edges, consider them as start and end of the face loop */\r\n            /* THIS METHOD WILL BE USED BY BOOLEAN OPERATIONS */\r\n            /* Assume that edges already copied to polygon.edges set in the clip algorithm !!! */\r\n            if (args.length == 2 && args[0] instanceof Edge && args[1] instanceof Edge) {\r\n                this.first = args[0];                          // first edge in face or undefined\r\n                this.last = args[1];                           // last edge in face or undefined\r\n                this.last.next = this.first;\r\n                this.first.prev = this.last;\r\n\r\n                // set arc length\r\n                this.setArcLength();\r\n                /*\r\n                 let edge = this.first;\r\n                 edge.arc_length = 0;\r\n                 edge = edge.next;\r\n                 while (edge !== this.first) {\r\n                 edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n                 edge = edge.next;\r\n                 }\r\n                 */\r\n\r\n                // this.box = this.getBox();\r\n                // this.orientation = this.getOrientation();      // face direction cw or ccw\r\n            }\r\n        }\r\n\r\n        [Symbol.iterator]() {\r\n            let edge = undefined;\r\n            return {\r\n                next: () => {\r\n                    let value = edge ? edge : this.first;\r\n                    let done = this.first ? (edge ? edge === this.first : false) : true;\r\n                    edge = value ? value.next : undefined;\r\n                    return {value: value, done: done};\r\n                }\r\n            };\r\n        };\r\n\r\n        /**\r\n         * Return array of edges from first to last\r\n         * @returns {Array}\r\n         */\r\n        get edges() {\r\n            let face_edges = [];\r\n            for (let edge of this) {\r\n                face_edges.push(edge);\r\n            }\r\n            return face_edges;\r\n        }\r\n\r\n        /**\r\n         * Return number of edges in the face\r\n         * @returns {number}\r\n         */\r\n        get size() {\r\n            let counter = 0;\r\n            for (let edge of this) {\r\n                counter++;\r\n            }\r\n            return counter;\r\n        }\r\n\r\n        /**\r\n         * Return bounding box of the face\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            if (this._box === undefined) {\r\n                let box = new Flatten.Box();\r\n                for (let edge of this) {\r\n                    box = box.merge(edge.box);\r\n                }\r\n                this._box = box;\r\n            }\r\n            return this._box;\r\n        }\r\n\r\n        static points2segments(points) {\r\n            let segments = [];\r\n            for (let i = 0; i < points.length; i++) {\r\n                segments.push(new Segment(points[i], points[(i + 1) % points.length]));\r\n            }\r\n            return segments;\r\n        }\r\n\r\n        shapes2face(edges, shapes) {\r\n            for (let shape of shapes) {\r\n                let edge = new Edge(shape);\r\n                this.append(edges, edge);\r\n                // this.box = this.box.merge(shape.box);\r\n                // edges.add(edge);\r\n            }\r\n            // this.orientation = this.getOrientation();              // face direction cw or ccw\r\n        }\r\n\r\n        /**\r\n         * Returns true if face is empty, false otherwise\r\n         * @returns {boolean}\r\n         */\r\n        isEmpty() {\r\n            return (this.first === undefined && this.last === undefined)\r\n        }\r\n\r\n        /**\r\n         * Append given edge after the last edge (and before the first edge). <br/>\r\n         * This method mutates current object and does not return any value\r\n         * @param {PlanarSet} edges - Container of edges\r\n         * @param {Edge} edge - Edge to be appended to the linked list\r\n         */\r\n        append(edges, edge) {\r\n            if (this.first === undefined) {\r\n                edge.prev = edge;\r\n                edge.next = edge;\r\n                this.first = edge;\r\n                this.last = edge;\r\n                edge.arc_length = 0;\r\n            }\r\n            else {\r\n                // append to end\r\n                edge.prev = this.last;\r\n                this.last.next = edge;\r\n\r\n                // update edge to be last\r\n                this.last = edge;\r\n\r\n                // restore circular links\r\n                this.last.next = this.first;\r\n                this.first.prev = this.last;\r\n\r\n                // set arc length\r\n                edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n            }\r\n            edge.face = this;\r\n\r\n            edges.add(edge);      // Add new edges into edges container\r\n        }\r\n\r\n        /**\r\n         * Insert edge newEdge into the linked list after the edge edgeBefore <br/>\r\n         * This method mutates current object and does not return any value\r\n         * @param {PlanarSet} edges - Container of edges\r\n         * @param {Edge} newEdge - Edge to be inserted into linked list\r\n         * @param {Edge} edgeBefore - Edge to insert newEdge after it\r\n         */\r\n        insert(edges, newEdge, edgeBefore) {\r\n            if (this.first === undefined) {\r\n                newEdge.prev = newEdge;\r\n                newEdge.next = newEdge;\r\n                this.first = newEdge;\r\n                this.last = newEdge;\r\n            }\r\n            else {\r\n                /* set links to new edge */\r\n                let edgeAfter = edgeBefore.next;\r\n                edgeBefore.next = newEdge;\r\n                edgeAfter.prev = newEdge;\r\n\r\n                /* set links from new edge */\r\n                newEdge.prev = edgeBefore;\r\n                newEdge.next = edgeAfter;\r\n\r\n                /* extend chain if new edge added after last edge */\r\n                if (this.last === edgeBefore)\r\n                    this.first = newEdge;\r\n            }\r\n            newEdge.face = this;\r\n\r\n            // set arc length\r\n            if (newEdge.prev === this.last) {\r\n                newEdge.arc_length = 0;\r\n            }\r\n            else {\r\n                newEdge.arc_length = newEdge.prev.arc_length + newEdge.prev.length;\r\n            }\r\n\r\n            edges.add(newEdge);      // Add new edges into edges container\r\n        }\r\n\r\n        /**\r\n         * Remove the given edge from the linked list of the face <br/>\r\n         * This method mutates current object and does not return any value\r\n         * @param {PlanarSet} edges - Container of edges\r\n         * @param {Edge} edge - Edge to be removed\r\n         */\r\n        remove(edges, edge) {\r\n            // special case if last edge removed\r\n            if (edge === this.first && edge === this.last) {\r\n                this.first = undefined;\r\n                this.last = undefined;\r\n            }\r\n            else {\r\n                // update linked list\r\n                edge.prev.next = edge.next;\r\n                edge.next.prev = edge.prev;\r\n                // update first if need\r\n                if (edge === this.first) {\r\n                    this.first = edge.next;\r\n                }\r\n                // update last if need\r\n                if (edge === this.last) {\r\n                    this.last = edge.prev;\r\n                }\r\n            }\r\n            edges.delete(edge);      // delete from PlanarSet of edges and update index\r\n        }\r\n\r\n        /**\r\n         * Reverse orientation of the face: first edge become last and vice a verse,\r\n         * all edges starts and ends swapped, direction of arcs inverted.\r\n         */\r\n        reverse() {\r\n            // collect edges in revert order with reverted shapes\r\n            let edges = [];\r\n            let edge_tmp = this.last;\r\n            do {\r\n                // reverse shape\r\n                edge_tmp.shape = edge_tmp.shape.reverse();\r\n                edges.push(edge_tmp);\r\n                edge_tmp = edge_tmp.prev;\r\n            } while (edge_tmp !== this.last);\r\n\r\n            // restore linked list\r\n            this.first = undefined;\r\n            this.last = undefined;\r\n            for (let edge of edges) {\r\n                if (this.first === undefined) {\r\n                    edge.prev = edge;\r\n                    edge.next = edge;\r\n                    this.first = edge;\r\n                    this.last = edge;\r\n                    edge.arc_length = 0;\r\n                }\r\n                else {\r\n                    // append to end\r\n                    edge.prev = this.last;\r\n                    this.last.next = edge;\r\n\r\n                    // update edge to be last\r\n                    this.last = edge;\r\n\r\n                    // restore circular links\r\n                    this.last.next = this.first;\r\n                    this.first.prev = this.last;\r\n\r\n                    // set arc length\r\n                    edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n                }\r\n            }\r\n\r\n            // Recalculate orientation, if set\r\n            if (this._orientation !== undefined) {\r\n                this._orientation = undefined;\r\n                this._orientation = this.orientation();\r\n            }\r\n        }\r\n\r\n\r\n        /**\r\n         * Set arc_length property for each of the edges in the face.\r\n         * Arc_length of the edge it the arc length from the first edge of the face\r\n         */\r\n        setArcLength() {\r\n            for (let edge of this) {\r\n                if (edge === this.first) {\r\n                    edge.arc_length = 0.0;\r\n                }\r\n                else {\r\n                    edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n                }\r\n                edge.face = this;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns the absolute value of the area of the face\r\n         * @returns {number}\r\n         */\r\n        area() {\r\n            return Math.abs(this.signedArea());\r\n        }\r\n\r\n        /**\r\n         * Returns signed area of the simple face.\r\n         * Face is simple if it has no self intersections that change its orientation.\r\n         * Then the area will be positive if the orientation of the face is clockwise,\r\n         * and negative if orientation is counterclockwise.\r\n         * It may be zero if polygon is degenerated.\r\n         * @returns {number}\r\n         */\r\n        signedArea() {\r\n            let sArea = 0;\r\n            let ymin = this.box.ymin;\r\n            for (let edge of this) {\r\n                sArea += edge.shape.definiteIntegral(ymin);\r\n            }\r\n            return sArea;\r\n        }\r\n\r\n        /**\r\n         * Return face orientation: one of Flatten.ORIENTATION.CCW, Flatten.ORIENTATION.CW, Flatten.ORIENTATION.NOT_ORIENTABLE <br/>\r\n         * According to Green theorem the area of a closed curve may be calculated as double integral,\r\n         * and the sign of the integral will be defined by the direction of the curve.\r\n         * When the integral (\"signed area\") will be negative, direction is counter clockwise,\r\n         * when positive - clockwise and when it is zero, polygon is not orientable.\r\n         * See {@link https://mathinsight.org/greens_theorem_find_area}\r\n         * @returns {number}\r\n         */\r\n        orientation() {\r\n            if (this._orientation === undefined) {\r\n                let area = this.signedArea();\r\n                if (Flatten.Utils.EQ_0(area)) {\r\n                    this._orientation = Flatten.ORIENTATION.NOT_ORIENTABLE;\r\n                }\r\n                else if (Flatten.Utils.LT(area, 0)) {\r\n                    this._orientation = Flatten.ORIENTATION.CCW;\r\n                }\r\n                else {\r\n                    this._orientation = Flatten.ORIENTATION.CW;\r\n                }\r\n            }\r\n            return this._orientation;\r\n        }\r\n\r\n        /**\r\n         * Returns true if face of the polygon is simple (no self-intersection points found)\r\n         * NOTE: this method is incomplete because it doe not exclude touching points\r\n         * Real self intersection inverts orientation of the polygon.\r\n         * But this is also good enough for the demonstration of the idea\r\n         * @param {Edges} edges - reference to polygon.edges to provide search index\r\n         * @returns {boolean}\r\n         */\r\n        isSimple(edges) {\r\n            let ip = Face.getSelfIntersections(this, edges, true);\r\n            return ip.length == 0;\r\n        }\r\n\r\n        static getSelfIntersections(face, edges, exitOnFirst = false) {\r\n            let int_points = [];\r\n\r\n            // calculate intersections\r\n            for (let edge1 of face) {\r\n\r\n                // request edges of polygon in the box of edge1\r\n                let resp = edges.search(edge1.box);\r\n\r\n                // for each edge2 in response\r\n                for (let edge2 of resp) {\r\n\r\n                    // Skip itself\r\n                    if (edge1 === edge2)\r\n                        continue;\r\n\r\n                    // Skip next and previous edge if both are segment (if one of them arc - calc intersection)\r\n                    if (edge1.shape instanceof Flatten.Segment && edge2.shape instanceof Flatten.Segment &&\r\n                        (edge1.next === edge2 || edge1.prev === edge2))\r\n                        continue;\r\n\r\n                    // calculate intersections between edge1 and edge2\r\n                    let ip = edge1.shape.intersect(edge2.shape);\r\n\r\n                    // for each intersection point\r\n                    for (let pt of ip) {\r\n\r\n                        // skip start-end connections\r\n                        if (pt.equalTo(edge1.start) && pt.equalTo(edge2.end) && edge2 === edge1.prev)\r\n                            continue;\r\n                        if (pt.equalTo(edge1.end) && pt.equalTo(edge2.start) && edge2 === edge1.next)\r\n                            continue;\r\n\r\n                        int_points.push(pt);\r\n\r\n                        if (exitOnFirst)\r\n                            break;\r\n                    }\r\n\r\n                    if (int_points.length > 0 && exitOnFirst)\r\n                        break;\r\n                }\r\n\r\n                if (int_points.length > 0 && exitOnFirst)\r\n                    break;\r\n\r\n            }\r\n            return int_points;\r\n        }\r\n\r\n        toJSON() {\r\n            return this.edges.map(edge => edge.toJSON());\r\n        }\r\n\r\n        /**\r\n         * Returns string to be assigned to \"d\" attribute inside defined \"path\"\r\n         * @returns {string}\r\n         */\r\n        svg() {\r\n            let svgStr = `\\nM${this.first.start.x},${this.first.start.y}`;\r\n            for (let edge of this) {\r\n                svgStr += edge.svg();\r\n            }\r\n            svgStr += ` z`;\r\n            return svgStr;\r\n        }\r\n\r\n    };\r\n};","/**\r\n * Created by Alex Bol on 2/20/2017.\r\n */\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing a line\r\n     * @type {Line}\r\n     */\r\n    Flatten.Line = class Line {\r\n        /**\r\n         * Line may be constructed by point and normal vector or by two points that a line passes through\r\n         * @param {Point} pt - point that a line passes through\r\n         * @param {Vector|Point} norm - normal vector to a line or second point a line passes through\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * Point a line passes through\r\n             * @type {Point}\r\n             */\r\n            this.pt = new Flatten.Point();\r\n            /**\r\n             * Normal vector to a line <br/>\r\n             * Vector is normalized (length == 1)\r\n             * @type {Vector}\r\n             */\r\n            this.norm = new Flatten.Vector(0,1);\r\n\r\n            if (args.length == 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length == 1 && args[0] instanceof Object && args[0].name === \"line\") {\r\n                let {pt, norm} = args[0];\r\n                this.pt = new Flatten.Point(pt);\r\n                this.norm = new Flatten.Vector(norm);\r\n                return;\r\n            }\r\n\r\n            if (args.length == 2) {\r\n                let a1 = args[0];\r\n                let a2 = args[1];\r\n\r\n                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\r\n                    this.pt = a1;\r\n                    this.norm = Line.points2norm(a1, a2);\r\n                    return;\r\n                }\r\n\r\n                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Vector) {\r\n                    if (Flatten.Utils.EQ_0(a2.x) && Flatten.Utils.EQ_0(a2.y)) {\r\n                        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n                    }\r\n                    this.pt = a1.clone();\r\n                    this.norm = a2.clone();\r\n                    this.norm = this.norm.normalize();\r\n                    return;\r\n                }\r\n\r\n                if (a1 instanceof Flatten.Vector && a2 instanceof Flatten.Point) {\r\n                    if (Flatten.Utils.EQ_0(a1.x) && Flatten.Utils.EQ_0(a1.y)) {\r\n                        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n                    }\r\n                    this.pt = a2.clone();\r\n                    this.norm = a1.clone();\r\n                    this.norm = this.norm.normalize();\r\n                    return;\r\n                }\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Returns cloned new instance of a line\r\n         * @returns {Line}\r\n         */\r\n        clone() {\r\n            return new Flatten.Line(this.pt, this.norm);\r\n        }\r\n\r\n        /**\r\n         * Slope of the line - angle in radians between line and axe x from 0 to 2PI\r\n         * @returns {number} - slope of the line\r\n         */\r\n        get slope() {\r\n            let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\r\n            return vec.slope;\r\n        }\r\n\r\n        /**\r\n         * Get coefficients [A,B,C] of a standard line equation in the form Ax + By = C\r\n         * @code [A, B, C] = line.standard\r\n         * @returns {number[]} - array of coefficients\r\n         */\r\n        get standard() {\r\n            let A = this.norm.x;\r\n            let B = this.norm.y;\r\n            let C = this.norm.dot(this.pt);\r\n\r\n            return [A,B,C];\r\n        }\r\n\r\n        /**\r\n         * Return true if parallel or incident to other line\r\n         * @param {Line} other_line - line to check\r\n         * @returns {boolean}\r\n         */\r\n        parallelTo(other_line) {\r\n            return Flatten.Utils.EQ_0(this.norm.cross(other_line.norm));\r\n        }\r\n\r\n        /**\r\n         * Returns true if incident to other line\r\n         * @param {Line} other_line - line to check\r\n         * @returns {boolean}\r\n         */\r\n        incidentTo(other_line) {\r\n            return this.parallelTo(other_line) && this.pt.on(other_line);\r\n        }\r\n\r\n        /**\r\n         * Returns true if point belongs to line\r\n         * @param {Point} pt Query point\r\n         * @returns {boolean}\r\n         */\r\n        contains(pt) {\r\n            if (this.pt.equalTo(pt)) {\r\n                return true;\r\n            }\r\n            /* Line contains point if vector to point is orthogonal to the line normal vector */\r\n            let vec = new Flatten.Vector(this.pt, pt);\r\n            return Flatten.Utils.EQ_0(this.norm.dot(vec));\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points\r\n         * @param {Shape} shape - shape to intersect with\r\n         * @returns {Point[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.contains(shape) ? [shape] : [];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                return Line.intersectLine2Line(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Line.intersectLine2Circle(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                return shape.intersect(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                return Line.intersectLine2Arc(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return Flatten.Polygon.intersectLine2Polygon(this, shape);\r\n            }\r\n\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from line to shape and returns array [distance, shortest_segment]\r\n         * @param {Shape} shape Shape of the one of the types Point, Circle, Segment, Arc, Polygon\r\n         * @returns {Number}\r\n         * @returns {Segment}\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [distance, shortest_segment] = Distance.point2line(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                let [distance, shortest_segment] = Distance.circle2line(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                let [distance, shortest_segment] = Distance.segment2line(shape, this);\r\n                return [distance, shortest_segment.reverse()];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                let [distance, shortest_segment] = Distance.arc2line(shape, this);\r\n                return [distance, shortest_segment.reverse()];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                let [distance, shortest_segment] = Distance.shape2polygon(this, shape);\r\n                return [distance, shortest_segment];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Return string to draw svg segment representing line inside given box\r\n         * @param {Box} box Box representing drawing area\r\n         * @param {Object} attrs - an object with attributes of svg circle element\r\n         */\r\n        svg(box, attrs = {}) {\r\n            let ip = Line.intersectLine2Box(this, box);\r\n            if (ip.length === 0)\r\n                return \"\";\r\n            let ps = ip[0];\r\n            let pe = ip.length == 2 ? ip[1] : ip.find( pt => !pt.equalTo(ps) );\r\n            if (pe === undefined) pe = ps;\r\n            let segment = new Flatten.Segment(ps, pe);\r\n            return segment.svg(attrs);\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"line\"});\r\n        }\r\n\r\n        static points2norm(pt1, pt2) {\r\n            if (pt1.equalTo(pt2)) {\r\n                throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n            }\r\n            let vec = new Flatten.Vector(pt1, pt2);\r\n            let unit = vec.normalize();\r\n            return unit.rotate90CCW();\r\n        }\r\n\r\n        static intersectLine2Line(line1, line2) {\r\n            let ip = [];\r\n\r\n            let [A1, B1, C1] = line1.standard;\r\n            let [A2, B2, C2] = line2.standard;\r\n\r\n            /* Cramer's rule */\r\n            let det = A1*B2 - B1*A2;\r\n            let detX = C1*B2 - B1*C2;\r\n            let detY = A1*C2 - C1*A2;\r\n\r\n            if (!Flatten.Utils.EQ_0(det)) {\r\n                let new_ip = new Flatten.Point( detX/det, detY/det );\r\n                ip.push(new_ip);\r\n            }\r\n            return ip;\r\n        }\r\n\r\n        static intersectLine2Circle(line, circle) {\r\n            let ip = [];\r\n            let prj = circle.pc.projectionOn(line);            // projection of circle center on line\r\n            let dist = circle.pc.distanceTo(prj)[0];           // distance from circle center to projection\r\n\r\n            if (Flatten.Utils.EQ(dist, circle.r)) {            // line tangent to circle - return single intersection point\r\n                ip.push(prj);\r\n            }\r\n            else if (Flatten.Utils.LT(dist, circle.r)) {       // return two intersection points\r\n                let delta = Math.sqrt(circle.r*circle.r - dist*dist);\r\n                let v_trans, pt;\r\n\r\n                v_trans = line.norm.rotate90CCW().multiply(delta);\r\n                pt = prj.translate(v_trans);\r\n                ip.push(pt);\r\n\r\n                v_trans = line.norm.rotate90CW().multiply(delta);\r\n                pt = prj.translate(v_trans);\r\n                ip.push(pt);\r\n            }\r\n            return ip;\r\n        }\r\n\r\n        static intersectLine2Box(line, box) {\r\n            let pts = [\r\n                new Flatten.Point(box.xmin, box.ymin),\r\n                new Flatten.Point(box.xmax, box.ymin),\r\n                new Flatten.Point(box.xmax, box.ymax),\r\n                new Flatten.Point(box.xmin, box.ymax)\r\n            ];\r\n            let segs = [\r\n                new Flatten.Segment(pts[0], pts[1]),\r\n                new Flatten.Segment(pts[1], pts[2]),\r\n                new Flatten.Segment(pts[2], pts[3]),\r\n                new Flatten.Segment(pts[3], pts[0])\r\n            ];\r\n\r\n            let ips =  [];\r\n\r\n            for(let seg of segs) {\r\n                let ips_tmp = seg.intersect(line);\r\n                for (let ip of ips_tmp) {\r\n                    ips.push(ip);\r\n                }\r\n            };\r\n            return ips;\r\n        }\r\n\r\n        static intersectLine2Arc(line, arc) {\r\n            let ip = [];\r\n\r\n            if (Line.intersectLine2Box(line, arc.box).length == 0) {\r\n                return ip;\r\n            }\r\n\r\n            let circle = new Flatten.Circle(arc.pc, arc.r);\r\n            let ip_tmp = line.intersect(circle);\r\n            for (let pt of ip_tmp) {\r\n                if (pt.on(arc)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n\r\n            return ip;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Function to create line equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.line = (...args) => new Flatten.Line(...args);\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing an affine transformation 3x3 matrix:\r\n     * <pre>\r\n     *      [ a  c  tx\r\n     * A =    b  d  ty\r\n     *        0  0  1  ]\r\n     * </pre\r\n     * @type {Matrix}\r\n     */\r\n    Flatten.Matrix = class Matrix {\r\n        /**\r\n         * Construct new instance of affine transformation matrix <br/>\r\n         * If parameters omitted, construct identity matrix a = 1, d = 1\r\n         * @param {number} a - position(0,0)   sx*cos(alpha)\r\n         * @param {number} b - position (0,1)  sx*sin(alpha)\r\n         * @param {number} c - position (1,0)  -sy*sin(alpha)\r\n         * @param {number} d - position (1,1)  sy*cos(alpha)\r\n         * @param {number} tx - position (2,0) translation by x\r\n         * @param {number} ty - position (2,1) translation by y\r\n         */\r\n        constructor(a=1,b=0,c=0,d=1,tx=0,ty=0) {\r\n            this.a = a;\r\n            this.b = b;\r\n            this.c = c;\r\n            this.d = d;\r\n            this.tx = tx;\r\n            this.ty = ty;\r\n        }\r\n\r\n        /**\r\n         * Returns a clone of the Matrix instance.\r\n         * @return {Matrix}\r\n         **/\r\n        clone() {\r\n            return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);\r\n        };\r\n\r\n        /**\r\n         * Transform vector [x,y] using transformation matrix. <br/>\r\n         * Vector [x,y] is an abstract array[2] of numbers and not a FlattenJS object <br/>\r\n         * The result is also an abstract vector [x',y'] = A * [x,y]:\r\n         * <code>\r\n         * [x'       [ ax + by + tx\r\n         *  y'   =     cx + dy + ty\r\n         *  1]                    1 ]\r\n         * </code>\r\n         * @param {number[]} vector - array[2] of numbers\r\n         * @returns {number[]} transformation result - array[2] of numbers\r\n         */\r\n        transform(vector) {\r\n            return [\r\n                vector[0]*this.a+vector[1]*this.c+this.tx,\r\n                vector[0]*this.b+vector[1]*this.d+this.ty\r\n            ]\r\n        };\r\n\r\n        /**\r\n         * Returns result of multiplication of this matrix by other matrix\r\n         * @param {Matrix} other_matrix - matrix to multiply by\r\n         * @returns {Matrix}\r\n         */\r\n        multiply(other_matrix) {\r\n            return new Matrix(\r\n                this.a*other_matrix.a + this.c*other_matrix.b,\r\n                this.b*other_matrix.a + this.d*other_matrix.b,\r\n                this.a*other_matrix.c + this.c*other_matrix.d,\r\n                this.b*other_matrix.c + this.d*other_matrix.d,\r\n                this.a*other_matrix.tx + this.c*other_matrix.ty + this.tx,\r\n                this.b*other_matrix.tx + this.d*other_matrix.ty + this.ty\r\n            )\r\n        };\r\n\r\n        /**\r\n         * Return new matrix as a result of multiplication of the current matrix\r\n         * by the matrix(1,0,0,1,tx,ty)\r\n         * @param {number} tx - translation by x\r\n         * @param {number} ty - translation by y\r\n         * @returns {Matrix}\r\n         */\r\n        translate(...args) {\r\n            let tx, ty;\r\n            if (args.length == 1 && (args[0] instanceof Flatten.Vector)) {\r\n                tx = args[0].x;\r\n                ty = args[0].y;\r\n            }\r\n            else if (args.length == 2 && typeof(args[0]) == \"number\" && typeof(args[1]) == \"number\") {\r\n                tx = args[0];\r\n                ty = args[1];\r\n            }\r\n            else {\r\n                throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n            }\r\n            return this.multiply(new Matrix(1,0,0,1,tx,ty))\r\n        };\r\n\r\n        /**\r\n         * Return new matrix as a result of multiplication of the current matrix\r\n         * by the matrix that defines rotation by given angle (in radians) around\r\n         * point (0,0) in counter clockwise direction\r\n         * @param angle\r\n         * @returns {Matrix}\r\n         */\r\n        rotate(angle) {\r\n            let cos = Math.cos(angle);\r\n            let sin = Math.sin(angle);\r\n            return this.multiply(new Matrix(cos,sin,-sin,cos,0,0));\r\n        };\r\n\r\n        /**\r\n         * Return new matrix as a result of multiplication of the current matrix\r\n         * by the matrix (sx,0,0,sy,0,0) that defines scaling\r\n         * @param sx\r\n         * @param sy\r\n         * @returns {Matrix}\r\n         */\r\n        scale(sx, sy) {\r\n            return this.multiply(new Matrix(sx,0,0,sy,0,0));\r\n        };\r\n\r\n        /**\r\n         * Returns true if two matrix are equal parameter by parameter\r\n         * @param {Matrix} matrix - other matrix\r\n         * @returns {boolean} true if equal, false otherwise\r\n         */\r\n        equalTo(matrix) {\r\n            if (!Flatten.Utils.EQ(this.tx, matrix.tx)) return false;\r\n            if (!Flatten.Utils.EQ(this.ty, matrix.ty)) return false;\r\n            if (!Flatten.Utils.EQ(this.a, matrix.a)) return false;\r\n            if (!Flatten.Utils.EQ(this.b, matrix.b)) return false;\r\n            if (!Flatten.Utils.EQ(this.c, matrix.c)) return false;\r\n            if (!Flatten.Utils.EQ(this.d, matrix.d)) return false;\r\n            return true;\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Function to create matrix equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.matrix = (...args) => new Flatten.Matrix(...args);\r\n};\r\n","/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n\r\n/**\r\n *\r\n * @param Flatten\r\n */\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     *\r\n     * Class representing a point\r\n     * @type {Point}\r\n     */\r\n    Flatten.Point = class Point {\r\n        /**\r\n         * Point may be constructed by two numbers, or by array of two numbers\r\n         * @param {number} x - x-coordinate (float number)\r\n         * @param {number} y - y-coordinate (float number)\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * x-coordinate (float number)\r\n             * @type {number}\r\n             */\r\n            this.x = 0;\r\n            /**\r\n             * y-coordinate (float number)\r\n             * @type {number}\r\n             */\r\n            this.y = 0;\r\n\r\n            if (args.length === 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\r\n                let arr = args[0];\r\n                if (typeof(arr[0]) == \"number\" && typeof(arr[1]) == \"number\") {\r\n                    this.x = arr[0];\r\n                    this.y = arr[1];\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (args.length === 1 && args[0] instanceof Object && args[0].name === \"point\") {\r\n                let {x, y} = args[0];\r\n                this.x = x;\r\n                this.y = y;\r\n                return;\r\n            }\r\n\r\n            if (args.length === 2) {\r\n                if (typeof(args[0]) == \"number\" && typeof(args[1]) == \"number\") {\r\n                    this.x = args[0];\r\n                    this.y = args[1];\r\n                    return;\r\n                }\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns bounding box of a point\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return new Flatten.Box(this.x, this.y, this.x, this.y);\r\n        }\r\n\r\n        /**\r\n         * Method clone returns new copied instance of point\r\n         * @returns {Point}\r\n         */\r\n        clone() {\r\n            return new Flatten.Point(this.x, this.y);\r\n        }\r\n\r\n        get vertices() {\r\n            return [this.clone()];\r\n        }\r\n\r\n        /**\r\n         * Returns true if points are equal up to [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n         * @param {Point} pt Query point\r\n         * @returns {boolean}\r\n         */\r\n        equalTo(pt) {\r\n            return Flatten.Utils.EQ(this.x, pt.x) && Flatten.Utils.EQ(this.y, pt.y);\r\n        }\r\n\r\n        /**\r\n         * Defines predicate \"less than\" between points. Returns true if the point is less than query points, false otherwise <br/>\r\n         * By definition point1 < point2 if {point1.y < point2.y || point1.y == point2.y && point1.x < point2.y <br/>\r\n         * Numeric values compared with [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n         * @param {Point} pt Query point\r\n         * @returns {boolean}\r\n         */\r\n        lessThan(pt) {\r\n            if (Flatten.Utils.LT(this.y, pt.y))\r\n                return true;\r\n            if (Flatten.Utils.EQ(this.y, pt.y) && Flatten.Utils.LT(this.x, pt.x))\r\n                return true;\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Returns new point rotated by given angle around given center point.\r\n         * If center point is omitted, rotates around zero point (0,0).\r\n         * Positive value of angle defines rotation in counter clockwise direction,\r\n         * negative angle defines rotation in clockwise clockwise direction\r\n         * @param {number} angle - angle in radians\r\n         * @param {Point} [center=(0,0)] center\r\n         * @returns {Point}\r\n         */\r\n        rotate(angle, center = {x:0, y:0}) {\r\n            var x_rot = center.x + (this.x - center.x) * Math.cos(angle) - (this.y - center.y) * Math.sin(angle);\r\n            var y_rot = center.y + (this.x - center.x) * Math.sin(angle) + (this.y - center.y) * Math.cos(angle);\r\n\r\n            return new Flatten.Point(x_rot, y_rot);\r\n        }\r\n\r\n        /**\r\n         * Returns new point translated by given vector.\r\n         * Translation vector may by also defined by a pair of numbers.\r\n         * @param {Vector} vector - Translation vector defined as Flatten.Vector or\r\n         * @param {number|number} - Translation vector defined as pair of numbers\r\n         * @returns {Point}\r\n         */\r\n        translate(...args) {\r\n            if (args.length == 1 && (args[0] instanceof Flatten.Vector)) {\r\n                return new Flatten.Point(this.x + args[0].x, this.y + args[0].y);\r\n            }\r\n\r\n            if (args.length == 2 && typeof(args[0]) == \"number\" && typeof(args[1]) == \"number\") {\r\n                return new Flatten.Point(this.x + args[0], this.y + args[1]);\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Return new point transformed by affine transformation matrix m\r\n         * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\r\n         * @returns {Point}\r\n         */\r\n        transform(m) {\r\n            // let [x,y] = m.transform([this.x,this.y]);\r\n            return new Flatten.Point(m.transform([this.x,this.y]))\r\n        }\r\n\r\n        /**\r\n         * Returns projection point on given line\r\n         * @param {Line} line Line this point be projected on\r\n         * @returns {Point}\r\n         */\r\n        projectionOn(line) {\r\n            if (this.equalTo(line.pt))                   // this point equal to line anchor point\r\n                return this.clone();\r\n\r\n            let vec = new Flatten.Vector(this, line.pt);\r\n            if (Flatten.Utils.EQ_0(vec.cross(line.norm)))    // vector to point from anchor point collinear to normal vector\r\n                return line.pt.clone();\r\n\r\n            let dist = vec.dot(line.norm);             // signed distance\r\n            let proj_vec = line.norm.multiply(dist);\r\n            return this.translate(proj_vec);\r\n        }\r\n\r\n        /**\r\n         * Returns true if point belongs to the \"left\" semi-plane, which means, point belongs to the same semi plane where line normal vector points to\r\n         * Return false if point belongs to the \"right\" semi-plane or to the line itself\r\n         * @param {Line} line Query line\r\n         * @returns {boolean}\r\n         */\r\n        leftTo(line) {\r\n            let vec = new Flatten.Vector(line.pt, this);\r\n            let onLeftSemiPlane = Flatten.Utils.GT(vec.dot(line.norm), 0);\r\n            return onLeftSemiPlane;\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from point to shape and return as array [distance, shortest segment]\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n         * @returns {number} distance from point to shape\r\n         * @returns {Segment} shortest segment between point and shape (started at point, ended at shape)\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Point) {\r\n                let dx = shape.x - this.x;\r\n                let dy = shape.y - this.y;\r\n                return [Math.sqrt(dx*dx + dy*dy), new Flatten.Segment(this, shape)];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                return Distance.point2line(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Distance.point2circle(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                return Distance.point2segment(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                // let [dist, ...rest] = Distance.point2arc(this, shape);\r\n                // return dist;\r\n                return Distance.point2arc(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                // let [dist, ...rest] = Distance.point2polygon(this, shape);\r\n                // return dist;\r\n                return Distance.point2polygon(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.PlanarSet) {\r\n                return Distance.shape2planarSet(this, shape);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns true if point is on a shape, false otherwise\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon\r\n         * @returns {boolean}\r\n         */\r\n        on(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.equalTo(shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                return shape.contains(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return shape.contains(this);\r\n            }\r\n\r\n            if (shape instanceof  Flatten.Segment) {\r\n                return shape.contains(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                return shape.contains(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return shape.contains(this);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Return string to draw point in svg as circle with radius \"r\" <br/>\r\n         * Accept any valid attributes of svg elements as svg object\r\n         * Defaults attribues are: <br/>\r\n         * {\r\n         *    r:\"3\",\r\n         *    stroke:\"black\",\r\n         *    strokeWidth:\"1\",\r\n         *    fill:\"red\"\r\n         * }\r\n         * @param {Object} attrs - Any valid attributes of svg circle element, like \"r\", \"stroke\", \"strokeWidth\", \"fill\"\r\n         * @returns {String}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {r, stroke, strokeWidth, fill, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n            return `\\n<circle cx=\"${this.x}\" cy=\"${this.y}\" r=\"${r || 3}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"red\"}\" ${id_str} ${class_str} />`;\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"point\"});\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Function to create point equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.point = (...args) => new Flatten.Point(...args);\r\n};\r\n","/**\r\n * Created by Alex Bol on 3/15/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Edge, Face, PlanarSet, Box} = Flatten;\r\n    let {ray_shoot} = Flatten;\r\n    /**\r\n     * Class representing a polygon.<br/>\r\n     * Polygon in FlattenJS is a multipolygon comprised from a set of [faces]{@link Flatten.Face}. <br/>\r\n     * Face, in turn, is a closed loop of [edges]{@link Flatten.Edge}, where edge may be segment or circular arc<br/>\r\n     * @type {Polygon}\r\n     */\r\n    Flatten.Polygon = class Polygon {\r\n        /**\r\n         * Constructor creates new instance of polygon.<br/>\r\n         * New polygon is empty. Add face to the polygon using method <br/>\r\n         * <code>\r\n         *     polygon.addFace(Points[]|Segments[]|Arcs[])\r\n         * </code>\r\n         */\r\n        constructor() {\r\n            /**\r\n             * Container of faces (closed loops), may be empty\r\n             * @type {PlanarSet}\r\n             */\r\n            this.faces = new PlanarSet();\r\n            /**\r\n             * Container of edges\r\n             * @type {PlanarSet}\r\n             */\r\n            this.edges = new PlanarSet();\r\n        }\r\n\r\n        /**\r\n         * (Getter) Returns bounding box of the polygon\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return [...this.faces].reduce( (acc, face) => acc.merge(face.box), new Box() );\r\n        }\r\n\r\n        /**\r\n         * (Getter) Returns array of vertices\r\n         * @returns {Array}\r\n         */\r\n        get vertices() {\r\n            return [...this.edges].map( edge => edge.start);\r\n        }\r\n\r\n        /**\r\n         * Return true is polygon has no edges\r\n         * @returns {boolean}\r\n         */\r\n        isEmpty() {\r\n            return this.edges.size === 0;\r\n        }\r\n\r\n        /**\r\n         * Add new face to polygon. Returns added face\r\n         * @param {Points[]|Segments[]|Arcs[]|Circle|Box} args -  new face may be create with one of the following ways: <br/>\r\n         * 1) array of points that describe closed path (edges are segments) <br/>\r\n         * 2) array of shapes (segments and arcs) which describe closed path <br/>\r\n         * 3) circle - will be added as counterclockwise arc <br/>\r\n         * 4) box - will be added as counterclockwise rectangle <br/>\r\n         * You can chain method face.reverse() is you need to change direction of the creates face\r\n         * @returns {Face}\r\n         */\r\n        addFace(...args) {\r\n            let face = new Face(this, ...args);\r\n            this.faces.add(face);\r\n            return face;\r\n        }\r\n\r\n        /**\r\n         * Delete existing face from polygon\r\n         * @param {Face} face Face to be deleted\r\n         * @returns {boolean}\r\n         */\r\n        deleteFace(face) {\r\n            for (let edge of face) {\r\n                let deleted = this.edges.delete(edge);\r\n            }\r\n            let deleted = this.faces.delete(face);\r\n            return deleted;\r\n        }\r\n\r\n        /**\r\n         * Delete chain of edges from the face.\r\n         * @param {Face} face Face to remove chain\r\n         * @param {Edge} edgeFrom Start of the chain of edges to be removed\r\n         * @param {Edge} edgeTo End of the chain of edges to be removed\r\n         */\r\n        removeChain(face, edgeFrom, edgeTo) {\r\n            // Special case: all edges removed\r\n            if (edgeTo.next === edgeFrom) {\r\n                this.deleteFace(face);\r\n                return;\r\n            }\r\n            for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next ) {\r\n                face.remove(this.edges, edge);\r\n                // this.edges.delete(edge);      // delete from PlanarSet of edges and update index\r\n                if (face.isEmpty()) {\r\n                    this.deleteFace(face);    // delete from PlanarSet of faces and update index\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Add point as a new vertex and split edge. Point supposed to belong to an edge.\r\n         * When edge is split, new edge created from the start of the edge to the new vertex\r\n         * and inserted before current edge.\r\n         * Current edge is trimmed and updated. Method returns new edge added.\r\n         * @param {Edge} edge Edge to be split with new vertex and then trimmed from start\r\n         * @param {Point} pt Point to be added as a new vertex\r\n         * @returns {Edge}\r\n         */\r\n        addVertex(pt, edge) {\r\n            let shapes = edge.shape.split(pt);\r\n            if (shapes.length < 2) return;\r\n            let newEdge = new Flatten.Edge(shapes[0]);\r\n            let edgeBefore = edge.prev;\r\n\r\n            /* Insert first split edge into linked list after edgeBefore */\r\n            edge.face.insert(this.edges, newEdge, edgeBefore);\r\n\r\n            // Remove old edge from edges container and 2d index\r\n            this.edges.delete(edge);\r\n\r\n            // Update edge shape with second split edge keeping links\r\n            edge.shape = shapes[1];\r\n\r\n            // Add updated edge to the edges container and 2d index\r\n            this.edges.add(edge);\r\n\r\n            return newEdge;\r\n        }\r\n\r\n        reverse() {\r\n            for (let face of this.faces) {\r\n                face.reverse();\r\n            }\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Create new copied instance of the polygon\r\n         * @returns {Polygon}\r\n         */\r\n        clone() {\r\n            let polygon = new Polygon();\r\n            for (let face of this.faces) {\r\n                let shapes = [];\r\n                for (let edge of face) {\r\n                    shapes.push(edge.shape.clone());\r\n                }\r\n                polygon.addFace(shapes);\r\n            }\r\n            return polygon;\r\n        }\r\n\r\n        /**\r\n         * Returns area of the polygon. Area of an island will be added, area of a hole will be subtracted\r\n         * @returns {number}\r\n         */\r\n        area() {\r\n            let signedArea = [...this.faces].reduce((acc,face) => acc + face.signedArea(), 0);\r\n            return Math.abs(signedArea);\r\n        }\r\n\r\n        /**\r\n         * Returns true if polygon contains point, including polygon boundary, false otherwise\r\n         * Point in polygon test based on ray shooting algorithm\r\n         * @param {Point} point - test point\r\n         * @returns {boolean}\r\n         */\r\n        contains(point) {\r\n            let rel = ray_shoot(this, point);\r\n            return (rel == Flatten.INSIDE || rel == Flatten.BOUNDARY) ? true : false;\r\n        }\r\n\r\n        /**\r\n         * Return distance and shortest segment between polygon and other shape as array [distance, shortest_segment]\r\n         * @param {Shape} shape Shape of one of the types Point, Circle, Line, Segment, Arc or Polygon\r\n         * @returns {Number | Segment}\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [dist, shortest_segment] = Distance.point2polygon(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle ||\r\n            shape instanceof Flatten.Line ||\r\n            shape instanceof Flatten.Segment ||\r\n            shape instanceof Flatten.Arc) {\r\n                let [dist, shortest_segment] = Distance.shape2polygon(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            /* this method is bit faster */\r\n            if (shape instanceof  Flatten.Polygon) {\r\n                let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n                let dist, shortest_segment;\r\n\r\n                for (let edge of this.edges) {\r\n                    // let [dist, shortest_segment] = Distance.shape2polygon(edge.shape, shape);\r\n                    let min_stop = min_dist_and_segment[0];\r\n                    [dist, shortest_segment] = Distance.shape2planarSet(edge.shape, shape.edges, min_stop);\r\n                    if (Flatten.Utils.LT(dist, min_stop)) {\r\n                        min_dist_and_segment = [dist, shortest_segment];\r\n                    }\r\n                }\r\n                return min_dist_and_segment;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Return array of intersection points between polygon and other shape\r\n         * @param shape Shape of the one of supported types <br/>\r\n         * @returns {Point[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.contains(shape) ? [shape] : [];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                return Polygon.intersectLine2Polygon(shape, this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle ||\r\n                shape instanceof Flatten.Segment ||\r\n                shape instanceof Flatten.Arc) {\r\n                return Polygon.intersectShape2Polygon(shape, this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return Polygon.intersectPolygon2Polygon(shape, this);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Return true if polygon is valid for boolean operations\r\n         * Polygon is valid if <br/>\r\n         * 1. All faces are simple polygons (there are no self-intersected polygons) <br/>\r\n         * 2. All faces are orientable and there is no island inside island or hole inside hole - TODO <br/>\r\n         * 3. There is no intersections between faces (excluding touching) - TODO <br/>\r\n         * @returns {boolean}\r\n         */\r\n        isValid() {\r\n            let valid = true;\r\n            // 1. Polygon is invalid if at least one face is not simple\r\n            for (let face of this.faces) {\r\n                if (!face.isSimple(this.edges)) {\r\n                    valid = false;\r\n                    break;\r\n                }\r\n            }\r\n            // 2. TODO: check if no island inside island and no hole inside hole\r\n            // 3. TODO: check the there is no intersection between faces\r\n            return valid;\r\n        }\r\n\r\n        /**\r\n         * Returns new polygon translated by vector vec\r\n         * @param {Vector} vec\r\n         * @returns {Polygon}\r\n         */\r\n        translate(vec) {\r\n            let newPolygon = new Polygon();\r\n            for (let face of this.faces) {\r\n                let shapes = [];\r\n                for (let edge of face) {\r\n                    shapes.push(edge.shape.translate(vec));\r\n                }\r\n                newPolygon.addFace(shapes);\r\n            }\r\n            return newPolygon;\r\n        }\r\n\r\n        /**\r\n         * Return new polygon rotated by given angle around given point\r\n         * If point omitted, rotate around origin (0,0)\r\n         * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n         * @param {number} angle - rotation angle in radians\r\n         * @param {Point} center - rotation center, default is (0,0)\r\n         * @returns {Polygon} - new rotated polygon\r\n         */\r\n        rotate(angle=0, center=new Flatten.Point()) {\r\n            let newPolygon = new Polygon();\r\n            for (let face of this.faces) {\r\n                let shapes = [];\r\n                for (let edge of face) {\r\n                    shapes.push(edge.shape.rotate(angle, center));\r\n                }\r\n                newPolygon.addFace(shapes);\r\n            }\r\n            return newPolygon;\r\n        }\r\n\r\n        /**\r\n         * Return new polygon transformed using affine transformation matrix\r\n         * @param {Matrix} matrix - affine transformation matrix\r\n         * @returns {Polygon} - new polygon\r\n         */\r\n        transform(matrix = new Flatten.Matrix()) {\r\n            let newPolygon = new Polygon();\r\n            for (let face of this.faces) {\r\n                let shapes = [];\r\n                for (let edge of face) {\r\n                    shapes.push(edge.shape.transform(matrix));\r\n                }\r\n                newPolygon.addFace(shapes);\r\n            }\r\n            return newPolygon;\r\n        }\r\n\r\n        static intersectShape2Polygon(shape, polygon) {\r\n            let ip = [];\r\n\r\n            if ( polygon.isEmpty() || shape.box.not_intersect(polygon.box) ) {\r\n                return ip;\r\n            }\r\n\r\n            let resp_edges = polygon.edges.search(shape.box);\r\n\r\n            for (let edge of resp_edges) {\r\n                for (let pt of shape.intersect(edge.shape)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n\r\n            return ip;\r\n        }\r\n\r\n        static intersectLine2Polygon(line, polygon) {\r\n            let ip = [];\r\n\r\n            if ( polygon.isEmpty() ) {\r\n                return ip;\r\n            }\r\n\r\n            for (let edge of polygon.edges) {\r\n                for (let pt of line.intersect(edge.shape)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n\r\n            return ip;\r\n        }\r\n\r\n        static intersectPolygon2Polygon(polygon1, polygon2) {\r\n            let ip = [];\r\n\r\n            if (polygon1.isEmpty() || polygon2.isEmpty()) {\r\n                return ip;\r\n            }\r\n\r\n            if (polygon1.box.not_intersect(polygon2.box)) {\r\n                return ip;\r\n            }\r\n\r\n            for (let edge1 of polygon1.edges) {\r\n                for (let pt of Polygon.intersectShape2Polygon(edge1.shape, polygon2)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n\r\n            return ip;\r\n        }\r\n\r\n        /**\r\n         * Return string to draw polygon in svg\r\n         * @param attrs  - an object with attributes for svg path element,\r\n         * like \"stroke\", \"strokeWidth\", \"fill\", \"fillRule\", \"fillOpacity\"\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"lightcyan\", fillRule:\"evenodd\", fillOpacity: \"1\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {stroke, strokeWidth, fill, fillRule, fillOpacity, id, className} = attrs;\r\n            // let restStr = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n            let svgStr = `\\n<path stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"lightcyan\"}\" fill-rule=\"${fillRule || \"evenodd\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} d=\"`;\r\n            for (let face of this.faces) {\r\n                svgStr += face.svg();\r\n            }\r\n            svgStr += `\" >\\n</path>`;\r\n            return svgStr;\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return [...this.faces].map(face => face.toJSON());\r\n        }\r\n    }\r\n};","\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Point, Segment, Line, Circle, Arc, Box, Vector} = Flatten;\r\n    /**\r\n     * Class representing a horizontal ray, used by ray shooting algorithm\r\n     * @type {Ray}\r\n     */\r\n    Flatten.Ray = class Ray {\r\n        /**\r\n         * Construct ray by setting start point\r\n         * @param {Point} pt - start point\r\n         */\r\n        constructor(...args) {\r\n            this.pt = new Point();\r\n\r\n            if (args.length == 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length == 1 && args[0] instanceof Point) {\r\n                this.pt = args[0].clone();\r\n                return;\r\n            }\r\n\r\n            if (args.length == 2 && typeof(args[0]) == \"number\" && typeof(args[1]) == \"number\") {\r\n                this.pt = new Point(args[0], args[1]);\r\n                return;\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Returns copied instance of the ray object\r\n         * @returns {Ray}\r\n         */\r\n        clone() {\r\n            return new Ray(this.pt);\r\n        }\r\n\r\n        /**\r\n         * Returns half-infinite bounding box of the ray\r\n         * @returns {Box} - bounding box\r\n         */\r\n        get box() {\r\n            return new Box(\r\n                this.pt.x,\r\n                this.pt.y,\r\n                Number.POSITIVE_INFINITY,\r\n                this.pt.y\r\n            )\r\n        }\r\n\r\n        /**\r\n         * Return ray start point\r\n         * @returns {Point} - ray start point\r\n         */\r\n        get start() {\r\n            return this.pt;\r\n        }\r\n\r\n        /**\r\n         * Return ray normal vector (0,1) - horizontal ray\r\n         * @returns {Vector} - ray normal vector\r\n         */\r\n        get norm() {\r\n            return new Vector(0,1);\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points between ray and segment or arc\r\n         * @param {Segment|Arc} - Shape to intersect with ray\r\n         * @returns {Array} array of intersection points\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Segment) {\r\n                return this.intersectRay2Segment(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Arc) {\r\n                return this.intersectRay2Arc(this, shape);\r\n            }\r\n        }\r\n\r\n        intersectRay2Segment(ray, segment) {\r\n            let ip = [];\r\n\r\n            if (ray.box.not_intersect(segment.box)) {\r\n                return ip;\r\n            }\r\n\r\n            let line = new Line(ray.start, ray.norm);\r\n            let ip_tmp = line.intersect(segment);\r\n\r\n            for (let pt of ip_tmp) {\r\n                if (Flatten.Utils.GE(pt.x, ray.start.x)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n\r\n            /* If there were two intersection points between line and ray,\r\n            and now there is exactly one left, it means ray starts between these points\r\n            and there is another intersection point - start of the ray */\r\n            if (ip_tmp.length == 2 && ip.length == 1 && ray.start.on(line)) {\r\n                ip.push(ray.start);\r\n            }\r\n\r\n            return ip;\r\n        }\r\n\r\n        intersectRay2Arc(ray, arc) {\r\n            let ip = [];\r\n\r\n            if (ray.box.not_intersect(arc.box)) {\r\n                return ip;\r\n            }\r\n\r\n            let line = new Line(ray.start, ray.norm);\r\n            let ip_tmp = line.intersect(arc);\r\n\r\n            for (let pt of ip_tmp) {\r\n                if (Flatten.Utils.GE(pt.x, ray.start.x)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n            return ip;\r\n        }\r\n    };\r\n\r\n    Flatten.ray = (...args) => new Flatten.Ray(...args);\r\n};","/**\r\n * Created by Alex Bol on 3/10/2017.\r\n */\r\n\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function (Flatten) {\r\n    /**\r\n     * Class representing a segment\r\n     * @type {Segment}\r\n     */\r\n    Flatten.Segment = class Segment {\r\n        /**\r\n         *\r\n         * @param {Point} ps - start point\r\n         * @param {Point} pe - end point\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * Start point\r\n             * @type {Point}\r\n             */\r\n            this.ps = new Flatten.Point();\r\n            /**\r\n             * End Point\r\n             * @type {Point}\r\n             */\r\n            this.pe = new Flatten.Point();\r\n\r\n            if (args.length == 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length == 1 && args[0] instanceof Array && args[0].length == 4) {\r\n                let coords = args[0];\r\n                this.ps = new Flatten.Point(coords[0], coords[1]);\r\n                this.pe = new Flatten.Point(coords[2], coords[3]);\r\n                return;\r\n            }\r\n\r\n            if (args.length == 1 && args[0] instanceof Object && args[0].name === \"segment\") {\r\n                let {ps,pe} = args[0];\r\n                this.ps = new Flatten.Point(ps.x, ps.y);\r\n                this.pe = new Flatten.Point(pe.x, pe.y);\r\n                return;\r\n            }\r\n\r\n            if (args.length == 2 && args[0] instanceof Flatten.Point && args[1] instanceof Flatten.Point) {\r\n                this.ps = args[0].clone();\r\n                this.pe = args[1].clone();\r\n                return;\r\n            }\r\n\r\n            if (args.length == 4) {\r\n                this.ps = new Flatten.Point(args[0], args[1]);\r\n                this.pe = new Flatten.Point(args[2], args[3]);\r\n                return;\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Method clone copies segment and returns a new instance\r\n         * @returns {Segment}\r\n         */\r\n        clone() {\r\n            return new Flatten.Segment(this.start, this.end);\r\n        }\r\n\r\n        /**\r\n         * Start point\r\n         * @returns {Point}\r\n         */\r\n        get start() {\r\n            return this.ps;\r\n        }\r\n\r\n        /**\r\n         * End point\r\n         * @returns {Point}\r\n         */\r\n        get end() {\r\n            return this.pe;\r\n        }\r\n\r\n\r\n        /**\r\n         * Returns array of start and end point\r\n         * @returns [Point,Point]\r\n         */\r\n        get vertices() {\r\n            return [this.ps.clone(), this.pe.clone()];\r\n        }\r\n\r\n        /**\r\n         * Length of a segment\r\n         * @returns {number}\r\n         */\r\n        get length() {\r\n            return this.start.distanceTo(this.end)[0];\r\n        }\r\n\r\n        /**\r\n         * Slope of the line - angle to axe x in radians from 0 to 2PI\r\n         * @returns {number}\r\n         */\r\n        get slope() {\r\n            let vec = new Flatten.Vector(this.start, this.end);\r\n            return vec.slope;\r\n        }\r\n\r\n        /**\r\n         * Bounding box\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return new Flatten.Box(\r\n                Math.min(this.start.x, this.end.x),\r\n                Math.min(this.start.y, this.end.y),\r\n                Math.max(this.start.x, this.end.x),\r\n                Math.max(this.start.y, this.end.y)\r\n            )\r\n        }\r\n\r\n        /**\r\n         * Returns true if equals to query segment, false otherwise\r\n         * @param {Seg} seg - query segment\r\n         * @returns {boolean}\r\n         */\r\n        equalTo(seg) {\r\n            return this.ps.equalTo(seg.ps) && this.pe.equalTo(seg.pe);\r\n        }\r\n\r\n        /**\r\n         * Returns true if segment contains point\r\n         * @param {Point} pt Query point\r\n         * @returns {boolean}\r\n         */\r\n        contains(pt) {\r\n            return Flatten.Utils.EQ_0(this.distanceToPoint(pt));\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points between segment and other shape\r\n         * @param {Shape} shape - Shape of the one of supported types <br/>\r\n         * @returns {Point[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.contains(shape) ? [shape] : [];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                return Segment.intersectSegment2Line(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                return Segment.intersectSegment2Segment(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Segment.intersectSegment2Circle(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                return Segment.intersectSegment2Arc(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return Flatten.Polygon.intersectShape2Polygon(this, shape);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from segment to shape and return as array [distance, shortest segment]\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n         * @returns {number} distance from segment to shape\r\n         * @returns {Segment} shortest segment between segment and shape (started at segment, ended at shape)\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [dist, shortest_segment] = Distance.point2segment(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                let [dist, shortest_segment] = Distance.segment2circle(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                let [dist, shortest_segment] = Distance.segment2line(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                let [dist, shortest_segment] = Distance.segment2segment(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                let [dist, shortest_segment] = Distance.segment2arc(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                let [dist, shortest_segment] = Distance.shape2polygon(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.PlanarSet) {\r\n                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns unit vector in the direction from start to end\r\n         * @returns {Vector}\r\n         */\r\n        tangentInStart() {\r\n            let vec = new Flatten.Vector(this.start, this.end);\r\n            return vec.normalize();\r\n        }\r\n\r\n        /**\r\n         * Return unit vector in the direction from end to start\r\n         * @returns {Vector}\r\n         */\r\n        tangentInEnd() {\r\n            let vec = new Flatten.Vector(this.end, this.start);\r\n            return vec.normalize();\r\n        }\r\n\r\n        /**\r\n         * Returns new segment with swapped start and end points\r\n         * @returns {Segment}\r\n         */\r\n        reverse() {\r\n            return new Segment(this.end, this.start);\r\n        }\r\n\r\n        /**\r\n         * When point belongs to segment, return array of two segments split by given point,\r\n         * if point is inside segment. Returns clone of this segment if query point is incident\r\n         * to start or end point of the segment. Returns empty array if point does not belong to segment\r\n         * @param {Point} pt Query point\r\n         * @returns {Segment[]}\r\n         */\r\n        split(pt) {\r\n            if (!this.contains(pt))\r\n                return [];\r\n\r\n            if (this.start.equalTo(this.end))\r\n                return [this.clone()];\r\n\r\n            if (this.start.equalTo(pt) || this.end.equalTo(pt))\r\n                return [this];\r\n\r\n            return [\r\n                new Flatten.Segment(this.start, pt),\r\n                new Flatten.Segment(pt, this.end)\r\n            ]\r\n        }\r\n\r\n        /**\r\n         * Return middle point of the segment\r\n         * @returns {Point}\r\n         */\r\n        middle() {\r\n            return new Flatten.Point((this.start.x + this.end.x)/2, (this.start.y + this.end.y)/2);\r\n        }\r\n\r\n        distanceToPoint(pt) {\r\n            let [dist, ...rest] = Flatten.Distance.point2segment(pt, this);\r\n            return dist;\r\n        };\r\n\r\n        definiteIntegral(ymin = 0.0) {\r\n            let dx = this.end.x - this.start.x;\r\n            let dy1 = this.start.y - ymin;\r\n            let dy2 = this.end.y - ymin;\r\n            return ( dx * (dy1 + dy2) / 2 );\r\n        }\r\n\r\n        /**\r\n         * Returns new segment translated by vector vec\r\n         * @param {Vector} vec\r\n         * @returns {Segment}\r\n         */\r\n        translate(...args) {\r\n            return new Segment(this.ps.translate(...args), this.pe.translate(...args));\r\n        }\r\n\r\n        /**\r\n         * Return new segment rotated by given angle around given point\r\n         * If point omitted, rotate around origin (0,0)\r\n         * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n         * @param {number} angle - rotation angle in radians\r\n         * @param {Point} center - center point, default is (0,0)\r\n         * @returns {Segment}\r\n         */\r\n        rotate(angle = 0, center = new Flatten.Point()) {\r\n            let m = new Flatten.Matrix();\r\n            m = m.translate(center.x, center.y).rotate(angle).translate(-center.x, -center.y);\r\n            return this.transform(m);\r\n        }\r\n\r\n        /**\r\n         * Return new segment transformed using affine transformation matrix\r\n         * @param {Matrix} matrix - affine transformation matrix\r\n         * @returns {Segment} - transformed segment\r\n         */\r\n        transform(matrix = new Flatten.Matrix()) {\r\n            return new Segment(this.ps.transform(matrix), this.pe.transform(matrix))\r\n        }\r\n\r\n        /**\r\n         * Returns true if segment start is equal to segment end up to DP_TOL\r\n         * @returns {boolean}\r\n         */\r\n        isZeroLength() {\r\n            return this.ps.equalTo(this.pe)\r\n        }\r\n\r\n        static intersectSegment2Line(seg, line) {\r\n            let ip = [];\r\n\r\n            // Boundary cases\r\n            if (seg.ps.on(line)) {\r\n                ip.push(seg.ps);\r\n            }\r\n            // If both ends lay on line, return two intersection points\r\n            if (seg.pe.on(line) && !seg.isZeroLength()) {\r\n                ip.push(seg.pe);\r\n            }\r\n\r\n            if (ip.length > 0) {\r\n                return ip;          // done, intersection found\r\n            }\r\n\r\n            // If zero-length segment and nothing found, return no intersections\r\n            if (seg.isZeroLength()) {\r\n                return ip;\r\n            }\r\n\r\n            // Not a boundary case, check if both points are on the same side and\r\n            // hence there is no intersection\r\n            if (seg.ps.leftTo(line) && seg.pe.leftTo(line) ||\r\n                !seg.ps.leftTo(line) && !seg.pe.leftTo(line)) {\r\n                return ip;\r\n            }\r\n\r\n            // Calculate intersection between lines\r\n            let line1 = new Flatten.Line(seg.ps, seg.pe);\r\n            return line1.intersect(line);\r\n        }\r\n\r\n        static intersectSegment2Segment(seg1, seg2) {\r\n            let ip = [];\r\n\r\n            // quick reject\r\n            if (seg1.box.not_intersect(seg2.box)) {\r\n                return ip;\r\n            }\r\n\r\n            // Special case of seg1 zero length\r\n            if (seg1.isZeroLength()) {\r\n                if (seg1.ps.on(seg2)) {\r\n                    ip.push(seg1.ps);\r\n                }\r\n                return ip;\r\n            }\r\n\r\n            // Special case of seg2 zero length\r\n            if (seg2.isZeroLength()) {\r\n                if (seg2.ps.on(seg1)) {\r\n                    ip.push(seg2.ps);\r\n                }\r\n                return ip;\r\n            }\r\n\r\n            // Neither seg1 nor seg2 is zero length\r\n            let line1 = new Flatten.Line(seg1.ps, seg1.pe);\r\n            let line2 = new Flatten.Line(seg2.ps, seg2.pe);\r\n\r\n            // Check overlapping between segments in case of incidence\r\n            // If segments touching, add one point. If overlapping, add two points\r\n            if (line1.incidentTo(line2)) {\r\n                if (seg1.ps.on(seg2)) {\r\n                    ip.push(seg1.ps);\r\n                }\r\n                if (seg1.pe.on(seg2)) {\r\n                    ip.push(seg1.pe);\r\n                }\r\n                if (seg2.ps.on(seg1) && !seg2.ps.equalTo(seg1.ps) && !seg2.ps.equalTo(seg1.pe)) {\r\n                    ip.push(seg2.ps);\r\n                }\r\n                if (seg2.pe.on(seg1) && !seg2.pe.equalTo(seg1.ps) && !seg2.pe.equalTo(seg1.pe)) {\r\n                    ip.push(seg2.pe);\r\n                }\r\n            }\r\n            else {                /* not incident - parallel or intersect */\r\n                // Calculate intersection between lines\r\n                let new_ip = line1.intersect(line2);\r\n                if (new_ip.length > 0 && new_ip[0].on(seg1) && new_ip[0].on(seg2)) {\r\n                    ip.push(new_ip[0]);\r\n                }\r\n            }\r\n\r\n            return ip;\r\n        }\r\n\r\n        static intersectSegment2Circle(segment, circle) {\r\n            let ips = [];\r\n\r\n            if (segment.box.not_intersect(circle.box)) {\r\n                return ips;\r\n            }\r\n\r\n            // Special case of zero length segment\r\n            if (segment.isZeroLength()) {\r\n                let [dist,shortest_segment] = segment.ps.distanceTo(circle.pc);\r\n                if (Flatten.Utils.EQ(dist, circle.r)) {\r\n                    ips.push(segment.ps);\r\n                }\r\n                return ips;\r\n            }\r\n\r\n            // Non zero-length segment\r\n            let line = new Flatten.Line(segment.ps, segment.pe);\r\n\r\n            let ips_tmp = line.intersect(circle);\r\n\r\n            for (let ip of ips_tmp) {\r\n                if (ip.on(segment)) {\r\n                    ips.push(ip);\r\n                }\r\n            }\r\n\r\n            return ips;\r\n        }\r\n\r\n        static intersectSegment2Arc(segment, arc) {\r\n            let ip = [];\r\n\r\n            if (segment.box.not_intersect(arc.box)) {\r\n                return ip;\r\n            }\r\n\r\n            // Special case of zero-length segment\r\n            if (segment.isZeroLength()) {\r\n                if (segment.ps.on(arc)) {\r\n                    ip.push(segment.ps);\r\n                }\r\n                return ip;\r\n            }\r\n\r\n            // Non-zero length segment\r\n            let line = new Flatten.Line(segment.ps, segment.pe);\r\n            let circle = new Flatten.Circle(arc.pc, arc.r);\r\n\r\n            let ip_tmp = line.intersect(circle);\r\n\r\n            for (let pt of ip_tmp) {\r\n                if (pt.on(segment) && pt.on(arc)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n            return ip;\r\n\r\n        }\r\n\r\n        /**\r\n         * Return string to draw segment in svg\r\n         * @param {Object} attrs - an object with attributes for svg path element,\r\n         * like \"stroke\", \"strokeWidth\" <br/>\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {stroke, strokeWidth, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n            return `\\n<line x1=\"${this.start.x}\" y1=\"${this.start.y}\" x2=\"${this.end.x}\" y2=\"${this.end.y}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" ${id_str} ${class_str} />`;\r\n\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"segment\"});\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Shortcut method to create new segment\r\n     */\r\n    Flatten.segment = (...args) => new Flatten.Segment(...args);\r\n};","/**\r\n * Created by Alex Bol on 2/19/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing a vector\r\n     * @type {Vector}\r\n     */\r\n    Flatten.Vector = class Vector {\r\n        /**\r\n         * Vector may be constructed by two points, or by two float numbers,\r\n         * or by array of two numbers\r\n         * @param {Point} ps - start point\r\n         * @param {Point} pe - end point\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * x-coordinate of a vector (float number)\r\n             * @type {number}\r\n             */\r\n            this.x = 0;\r\n            /**\r\n             * y-coordinate of a vector (float number)\r\n             * @type {number}\r\n             */\r\n            this.y = 0;\r\n\r\n            /* return zero vector */\r\n            if (args.length === 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\r\n                let arr = args[0];\r\n                if (typeof(arr[0]) == \"number\" && typeof(arr[1]) == \"number\") {\r\n                    this.x = arr[0];\r\n                    this.y = arr[1];\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (args.length === 1 && args[0] instanceof Object && args[0].name === \"vector\") {\r\n                let {x, y} = args[0];\r\n                this.x = x;\r\n                this.y = y;\r\n                return;\r\n            }\r\n\r\n            if (args.length === 2) {\r\n                let a1 = args[0];\r\n                let a2 = args[1];\r\n\r\n                if (typeof(a1) == \"number\" && typeof(a2) == \"number\") {\r\n                    this.x = a1;\r\n                    this.y = a2;\r\n                    return;\r\n                }\r\n\r\n                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\r\n                    this.x = a2.x - a1.x;\r\n                    this.y = a2.y - a1.y;\r\n                    return;\r\n                }\r\n\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Method clone returns new instance of Vector\r\n         * @returns {Vector}\r\n         */\r\n        clone() {\r\n            return new Vector(this.x, this.y);\r\n        }\r\n\r\n        /**\r\n         * Slope of the vector in radians from 0 to 2PI\r\n         * @returns {number}\r\n         */\r\n        get slope() {\r\n            let angle = Math.atan2(this.y, this.x);\r\n            if (angle<0) angle = 2*Math.PI + angle;\r\n            return angle;\r\n        }\r\n\r\n        /**\r\n         * Length of vector\r\n         * @returns {number}\r\n         */\r\n        get length() {\r\n            return Math.sqrt(this.dot(this));\r\n        }\r\n\r\n        /**\r\n         * Returns true if vectors are equal up to [DP_TOL]{@link http://localhost:63342/flatten-js/docs/global.html#DP_TOL}\r\n         * tolerance\r\n         * @param {Vector} v\r\n         * @returns {boolean}\r\n         */\r\n        equalTo(v) {\r\n            return Flatten.Utils.EQ(this.x, v.x) && Flatten.Utils.EQ(this.y, v.y);\r\n        }\r\n\r\n        /**\r\n         * Returns new vector multiplied by scalar\r\n         * @param {number} scalar\r\n         * @returns {Vector}\r\n         */\r\n        multiply(scalar) {\r\n            return ( new Vector(scalar * this.x, scalar * this.y) );\r\n        }\r\n\r\n        /**\r\n         * Returns scalar product (dot product) of two vectors <br/>\r\n         * <code>dot_product = (this * v)</code>\r\n         * @param {Vector} v Other vector\r\n         * @returns {number}\r\n         */\r\n        dot(v) {\r\n            return ( this.x * v.x + this.y * v.y );\r\n        }\r\n\r\n        /**\r\n         * Returns vector product (cross product) of two vectors <br/>\r\n         * <code>cross_product = (this x v)</code>\r\n         * @param {Vector} v Other vector\r\n         * @returns {number}\r\n         */\r\n        cross(v) {\r\n            return ( this.x * v.y - this.y * v.x );\r\n        }\r\n\r\n        /**\r\n         * Returns unit vector.<br/>\r\n         * Throw error if given vector has zero length\r\n         * @returns {Vector}\r\n         */\r\n        normalize() {\r\n            if (!Flatten.Utils.EQ_0(this.length)) {\r\n                return ( new Vector(this.x / this.length, this.y / this.length) );\r\n            }\r\n            throw Flatten.Errors.ZERO_DIVISION;\r\n        }\r\n\r\n        /**\r\n         * Returns new vector rotated by given angle,\r\n         * positive angle defines rotation in counter clockwise direction,\r\n         * negative - in clockwise direction\r\n         * @param {number} angle - Angle in radians\r\n         * @returns {Vector}\r\n         */\r\n        rotate(angle) {\r\n            let point = new Flatten.Point(this.x, this.y);\r\n            let rpoint = point.rotate(angle);\r\n            return new Flatten.Vector(rpoint.x, rpoint.y);\r\n        }\r\n\r\n        /**\r\n         * Returns vector rotated 90 degrees counter clockwise\r\n         * @returns {Vector}\r\n         */\r\n        rotate90CCW() {\r\n            return new Flatten.Vector(-this.y, this.x);\r\n        };\r\n\r\n        /**\r\n         * Returns vector rotated 90 degrees clockwise\r\n         * @returns {Vector}\r\n         */\r\n        rotate90CW() {\r\n            return new Flatten.Vector(this.y, -this.x);\r\n        };\r\n\r\n        /**\r\n         * Return inverted vector\r\n         * @returns {Vector}\r\n         */\r\n        invert() {\r\n            return new Flatten.Vector(-this.x, -this.y);\r\n        }\r\n\r\n        /**\r\n         * Return result of addition of other vector to this vector as a new vector\r\n         * @param {Vector} v Other vector\r\n         * @returns {Vector}\r\n         */\r\n        add(v) {\r\n            return new Flatten.Vector(this.x + v.x, this.y + v.y);\r\n        }\r\n\r\n        /**\r\n         * Return result of subtraction of other vector from current vector as a new vector\r\n         * @param {Vector} v Another vector\r\n         * @returns {Vector}\r\n         */\r\n        subtract(v) {\r\n            return new Flatten.Vector(this.x - v.x, this.y - v.y);\r\n        }\r\n\r\n        /**\r\n         * Return angle between this vector and other vector. <br/>\r\n         * Angle is measured from 0 to 2*PI in the counter clockwise direction\r\n         * from current vector to other.\r\n         * @param {Vector} v Another vector\r\n         * @returns {number}\r\n         */\r\n        angleTo(v) {\r\n            let norm1 = this.normalize();\r\n            let norm2 = v.normalize();\r\n            let angle = Math.atan2(norm1.cross(norm2), norm1.dot(norm2));\r\n            if (angle<0) angle += 2*Math.PI;\r\n            return angle;\r\n        }\r\n\r\n        /**\r\n         * Return vector projection of the current vector on another vector\r\n         * @param {Vector} v Another vector\r\n         * @returns {Vector}\r\n         */\r\n        projectionOn(v){\r\n            let n = v.normalize();\r\n            let d = this.dot(n);\r\n            return n.multiply(d);\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"vector\"});\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Function to create vector equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.vector = (...args) => new Flatten.Vector(...args);\r\n};\r\n","/**\r\n * Created by Alex Bol on 3/12/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\n// require(\"babel-polyfill\");\r\n\r\nlet IntervalTree = require('flatten-interval-tree');\r\n\r\nmodule.exports = function (Flatten) {\r\n    /**\r\n     * Class representing a planar set - a generic container with ability to keep and retrieve shapes and\r\n     * perform spatial queries. Planar set is an extension of Set container, so it supports\r\n     * Set properties and methods\r\n     */\r\n    Flatten.PlanarSet = class PlanarSet extends Set {\r\n        /**\r\n         * Create new empty instance of PlanarSet\r\n         */\r\n        constructor() {\r\n            super();\r\n            this.index = new IntervalTree();\r\n        }\r\n\r\n        /**\r\n         * Add new shape to planar set and to its spatial index.<br/>\r\n         * If shape already exist, it will not be added again.\r\n         * This happens with no error, it is possible to use <i>size</i> property to check if\r\n         * a shape was actually added.<br/>\r\n         * Method returns planar set object updated and may be chained\r\n         * @param {Shape} shape - shape to be added, should have valid <i>box</i> property\r\n         * @returns {PlanarSet}\r\n         */\r\n        add(shape) {\r\n            let size = this.size;\r\n            super.add(shape);\r\n            // size not changed - item not added, probably trying to add same item twice\r\n            if (this.size > size) {\r\n                let node = this.index.insert(shape.box, shape);\r\n            }\r\n            return this;         // in accordance to Set.add interface\r\n        }\r\n\r\n        /**\r\n         * Delete shape from planar set. Returns true if shape was actually deleted, false otherwise\r\n         * @param {Shape} shape - shape to be deleted\r\n         * @returns {boolean}\r\n         */\r\n        delete(shape) {\r\n            let deleted = super.delete(shape);\r\n            if (deleted) {\r\n                this.index.remove(shape.box, shape);\r\n            }\r\n            return deleted;\r\n        }\r\n\r\n        /**\r\n         * Clear planar set\r\n         */\r\n        clear() {\r\n            super.clear();\r\n            this.index = new IntervalTree();\r\n        }\r\n\r\n        /**\r\n         * 2d range search in planar set.<br/>\r\n         * Returns array of all shapes in planar set which bounding box is intersected with query box\r\n         * @param {Box} box - query box\r\n         * @returns {Shapes[]}\r\n         */\r\n        search(box) {\r\n            let resp = this.index.search(box);\r\n            return resp;\r\n        }\r\n\r\n        /**\r\n         * Point location test. Returns array of shapes which contains given point\r\n         * @param {Point} point - query point\r\n         * @returns {Array}\r\n         */\r\n        hit(point) {\r\n            let box = new Flatten.Box(point.x - 1, point.y - 1, point.x + 1, point.y + 1);\r\n            let resp = this.index.search(box);\r\n            return resp.filter((shape) => point.on(shape));\r\n        }\r\n\r\n        /**\r\n         * Returns svg string to draw all shapes in planar set\r\n         * @returns {String}\r\n         */\r\n        svg() {\r\n            let svgcontent = [...this].reduce((acc, shape) => acc + shape.svg(), \"\");\r\n            return svgcontent;\r\n        }\r\n    }\r\n};\r\n\r\n","/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n'use strict';\r\n\r\nlet Utils = require(\"./utils/utils\");\r\nlet Errors = require(\"./utils/errors\");\r\n\r\n/**\r\n * FlattenJS - library for 2d geometry\r\n * @type {Flatten}\r\n */\r\nlet Flatten = class Flatten {\r\n    constructor() {\r\n        this.DP_TOL = Utils.DP_TOL;\r\n        this.CCW = true;\r\n        this.CW = false;\r\n        this.ORIENTATION = {CCW:-1, CW:1, NOT_ORIENTABLE: 0};\r\n        this.PIx2 = 2 * Math.PI;\r\n        // this.PI_2 = 0.5 * Math.PI;\r\n        this.INSIDE = 1;\r\n        this.OUTSIDE = 0;\r\n        this.BOUNDARY = 2;\r\n        this.CONTAINS = 3;\r\n        this.INTERLACE = 4;\r\n        this.OVERLAP_SAME = 1;\r\n        this.OVERLAP_OPPOSITE = 2;\r\n        this.Utils = Utils;\r\n        this.Errors = Errors;\r\n    }\r\n};\r\n\r\nlet f = new Flatten();\r\n\r\nrequire(\"./classes/matrix\")(f);\r\nrequire(\"./data_structures/planar_set\")(f);\r\nrequire(\"./classes/point\")(f);\r\nrequire(\"./classes/vector\")(f);\r\nrequire(\"./classes/line\")(f);\r\nrequire(\"./classes/circle\")(f);\r\nrequire(\"./classes/segment\")(f);\r\nrequire(\"./classes/arc\")(f);\r\nrequire(\"./classes/box\")(f);\r\nrequire(\"./classes/edge\")(f);\r\nrequire(\"./classes/face\")(f);\r\nrequire(\"./classes/ray\")(f);\r\nrequire(\"./algorithms/ray_shooting\")(f);\r\nrequire(\"./classes/polygon\")(f);\r\nrequire(\"./algorithms/distance\")(f);\r\n\r\nmodule.exports = f;\r\n","/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\nlet Interval = class Interval {\r\n    constructor(low, high) {\r\n        this.low = low;\r\n        this.high = high;\r\n    }\r\n\r\n    get max() {\r\n        return this.high;\r\n    }\r\n\r\n    interval(low, high) {\r\n        return new Interval(low, high);\r\n    }\r\n\r\n    clone() {\r\n        return new Interval(this.low, this.high);\r\n    }\r\n\r\n    less_than(other_interval) {\r\n        return this.low < other_interval.low ||\r\n            this.low == other_interval.low && this.high < other_interval.high;\r\n    }\r\n\r\n    equal_to(other_interval) {\r\n        return this.low == other_interval.low && this.high == other_interval.high;\r\n    }\r\n\r\n    intersect(other_interval) {\r\n        return !this.not_intersect(other_interval);\r\n    }\r\n\r\n    not_intersect(other_interval) {\r\n        return (this.high < other_interval.low || other_interval.high < this.low);\r\n    }\r\n\r\n    output() {\r\n        return [this.low, this.high];\r\n    }\r\n\r\n    maximal_val(val1, val2) {\r\n        return Math.max(val1, val2);\r\n    }\r\n\r\n    val_less_than(val1, val2 ) {     // trait to compare max property with item ?\r\n        return val1 < val2;\r\n    }\r\n};\r\n\r\nmodule.exports = Interval;\r\n","/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\n'use strict';\r\n\r\n// let defaultTraits = require('../utils/numeric_traits');\r\nlet Interval = require('../classes/interval');\r\nlet {RB_TREE_COLOR_RED, RB_TREE_COLOR_BLACK} = require('../utils/constants');\r\n\r\nlet Node = class Node {\r\n    constructor(key = undefined, value = undefined,\r\n                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\r\n        this.left = left;                     // reference to left child node\r\n        this.right = right;                   // reference to right child node\r\n        this.parent = parent;                 // reference to parent node\r\n        this.color = color;\r\n\r\n        this.item = {key: key, value: value};   // key is supposed to be       instance of Interval\r\n\r\n        /* If not, this should by an array of two numbers */\r\n        if (key && key instanceof Array && key.length == 2) {\r\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\r\n                this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));\r\n            }\r\n        }\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n    }\r\n\r\n    isNil() {\r\n        return (this.item.key === undefined && this.item.value === undefined &&\r\n            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);\r\n    }\r\n\r\n    less_than(other_node) {\r\n        return this.item.key.less_than(other_node.item.key);\r\n    }\r\n\r\n    equal_to(other_node) {\r\n        let value_equal = true;\r\n        if (this.item.value && other_node.item.value) {\r\n            value_equal = this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) :\r\n                this.item.value == other_node.item.value;\r\n        }\r\n        return this.item.key.equal_to(other_node.item.key) && value_equal;\r\n    }\r\n\r\n    intersect(other_node) {\r\n        return this.item.key.intersect(other_node.item.key);\r\n    }\r\n\r\n    copy_data(other_node) {\r\n        this.item.key = other_node.item.key.clone();\r\n        this.item.value = other_node.item.value;\r\n    }\r\n\r\n    update_max() {\r\n        // use key (Interval) max property instead of key.high\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n        if (this.right && this.right.max) {\r\n            let maximal_val = this.item.key.maximal_val;\r\n            this.max = maximal_val(this.max, this.right.max);\r\n        }\r\n        if (this.left && this.left.max) {\r\n            let maximal_val = this.item.key.maximal_val;\r\n            this.max = maximal_val(this.max, this.left.max);\r\n        }\r\n    }\r\n\r\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\r\n    not_intersect_left_subtree(search_node) {\r\n        let val_less_than = this.item.key.val_less_than;\r\n        let high = this.left.max.high ? this.left.max.high : this.left.max;\r\n        return val_less_than(high, search_node.item.key.low);\r\n    }\r\n\r\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\r\n    not_intersect_right_subtree(search_node) {\r\n        let val_less_than = this.item.key.val_less_than;\r\n        let low = this.right.max.low ? this.right.max.low : this.right.item.key.low;\r\n        return val_less_than(search_node.item.key.high, low);\r\n    }\r\n};\r\n\r\nmodule.exports = Node;\r\n\r\n","/**\r\n * Created by Alex Bol on 3/31/2017.\r\n */\r\n'use strict';\r\n\r\nlet Node = require('./classes/node');\r\nlet {RB_TREE_COLOR_RED, RB_TREE_COLOR_BLACK} = require('./utils/constants');\r\n\r\nlet nil_node = new Node();\r\n\r\n/**\r\n * Implementation of interval binary search tree <br/>\r\n * Interval tree may store items which are couples of {key:interval, value: value} <br/>\r\n * Interval is an object with high and low properties or simply array of numeric [low,high] values <br />\r\n * If interval is an object, it should implement and expose methods less_than, equals_to, intersect and others,\r\n * see documentation {link}\r\n * @type {IntervalTree}\r\n */\r\nlet IntervalTree = class IntervalTree {\r\n    /**\r\n     * Construct new empty instance of IntervalTree\r\n     */\r\n    constructor() {\r\n        this.root = null;\r\n    }\r\n\r\n    /**\r\n     * Returns number of items stored in the interval tree\r\n     * @returns {number}\r\n     */\r\n    get size() {\r\n        let count = 0;\r\n        this.tree_walk(this.root, () => count++);\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * Returns array of sorted keys in the ascending order\r\n     * @returns {Array}\r\n     */\r\n    get keys() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push(node.item.key.output()));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Return array of values in the ascending keys order\r\n     * @returns {Array}\r\n     */\r\n    get values() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push(node.item.value));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns array of items (<key,value> pairs) in the ascended keys order\r\n     * @returns {Array}\r\n     */\r\n    get items() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push({key: node.item.key.output(), value: node.item.value}));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns true if tree is empty\r\n     * @returns {boolean}\r\n     */\r\n    get isEmpty() {\r\n        return (this.root == null || this.root == nil_node);\r\n    }\r\n\r\n    /**\r\n     * Insert new item into interval tree\r\n     * @param key - interval object or array of two numbers [low, high]\r\n     * @param value - value representing any object (optional)\r\n     * @returns {Node} - returns reference to inserted node as an object {key:interval, value: value}\r\n     */\r\n    insert(key, value = key) {\r\n        if (key === undefined) return;\r\n        let insert_node = new Node(key, value, nil_node, nil_node, null, RB_TREE_COLOR_RED);\r\n        this.tree_insert(insert_node);\r\n        this.recalc_max(insert_node);\r\n        return insert_node;\r\n    }\r\n\r\n    /**\r\n     * Returns true if item {key,value} exist in the tree\r\n     * @param key - interval correspondent to keys stored in the tree\r\n     * @param value - value object to be checked\r\n     * @returns {boolean} - true if item {key, value} exist in the tree, false otherwise\r\n     */\r\n    exist(key, value) {\r\n        let search_node = new Node(key, value);\r\n        return this.tree_search(this.root, search_node) ? true : false;\r\n    }\r\n\r\n    /**\r\n     * Remove entry {key, value} from the tree\r\n     * @param key - interval correspondent to keys stored in the tree\r\n     * @param value - - value object\r\n     * @returns {boolean} - true if item {key, value} deleted, false if not found\r\n     */\r\n    remove(key, value) {\r\n        let search_node = new Node(key, value);\r\n        let delete_node = this.tree_search(this.root, search_node);\r\n        if (delete_node) {\r\n            this.tree_delete(delete_node);\r\n        }\r\n        return delete_node;\r\n    }\r\n\r\n    /**\r\n     * Returns array of entry values which keys intersect with given interval <br/>\r\n     * If no values stored in the tree, returns array of keys which intersect given interval\r\n     * @param interval - search interval, or array [low, high]\r\n     * @returns {Array}\r\n     */\r\n    search(interval) {\r\n        let search_node = new Node(interval);\r\n        let resp_nodes = [];\r\n        this.tree_search_interval(this.root, search_node, resp_nodes);\r\n        let resp = [];\r\n        resp_nodes.forEach((node) => {\r\n            if (node.item.value) {         // if there are values, return only values\r\n                resp.push(node.item.value);\r\n            }\r\n            else {                         // otherwise, return keys\r\n                resp.push(node.item.key.output());\r\n            }\r\n        }, []);\r\n        return resp;\r\n    }\r\n\r\n    /**\r\n     * Tree visitor. For each node implement a callback function. <br/>\r\n     * Method calls a callback function with two parameters (key, value)\r\n     * @param visitor(key,value) - function to be called for each tree item\r\n     */\r\n    forEach(visitor) {\r\n        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));\r\n    }\r\n    \r\n    /** Value Mapper. Walk through every node and map node value to another value\r\n     * @param callback(value, key) - function to be called for each tree item\r\n     */\r\n    map(callback) {\r\n        const tree = new IntervalTree();\r\n        this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));\r\n        return tree;\r\n    }\r\n\r\n    recalc_max(node) {\r\n        let node_current = node;\r\n        while (node_current.parent != null) {\r\n            node_current.parent.update_max();\r\n            node_current = node_current.parent;\r\n        }\r\n    }\r\n\r\n    tree_insert(insert_node) {\r\n        let current_node = this.root;\r\n        let parent_node = null;\r\n\r\n        if (this.root == null || this.root == nil_node) {\r\n            this.root = insert_node;\r\n        }\r\n        else {\r\n            while (current_node != nil_node) {\r\n                parent_node = current_node;\r\n                if (insert_node.less_than(current_node)) {\r\n                    current_node = current_node.left;\r\n                }\r\n                else {\r\n                    current_node = current_node.right;\r\n                }\r\n            }\r\n\r\n            insert_node.parent = parent_node;\r\n\r\n            if (insert_node.less_than(parent_node)) {\r\n                parent_node.left = insert_node;\r\n            }\r\n            else {\r\n                parent_node.right = insert_node;\r\n            }\r\n        }\r\n\r\n        this.insert_fixup(insert_node);\r\n    }\r\n\r\n// After insertion insert_node may have red-colored parent, and this is a single possible violation\r\n// Go upwords to the root and re-color until violation will be resolved\r\n    insert_fixup(insert_node) {\r\n        let current_node;\r\n        let uncle_node;\r\n\r\n        current_node = insert_node;\r\n        while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {\r\n            if (current_node.parent == current_node.parent.parent.left) {   // parent is left child of grandfather\r\n                uncle_node = current_node.parent.parent.right;              // right brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 1. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {                                                    // Case 2 & 3. Uncle is black\r\n                    if (current_node == current_node.parent.right) {     // Case 2. Current if right child\r\n                        // This case is transformed into Case 3.\r\n                        current_node = current_node.parent;\r\n                        this.rotate_left(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.\r\n                    // Re-color father and grandfather, rotate grandfather right\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_right(current_node.parent.parent);\r\n                }\r\n            }\r\n            else {                                                         // parent is right child of grandfather\r\n                uncle_node = current_node.parent.parent.left;              // left brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 4. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {\r\n                    if (current_node == current_node.parent.left) {             // Case 5. Current is left child\r\n                        // Transform into case 6\r\n                        current_node = current_node.parent;\r\n                        this.rotate_right(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.\r\n                    // Re-color father and grandfather, rotate grandfather left\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_left(current_node.parent.parent);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.root.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_delete(delete_node) {\r\n        let cut_node;   // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\r\n        let fix_node;   // node to fix rb tree property   (\"x\" from 14.4)\r\n\r\n        if (delete_node.left == nil_node || delete_node.right == nil_node) {  // delete_node has less then 2 children\r\n            cut_node = delete_node;\r\n        }\r\n        else {                                                    // delete_node has 2 children\r\n            cut_node = this.tree_successor(delete_node);\r\n        }\r\n\r\n        // fix_node if single child of cut_node\r\n        if (cut_node.left != nil_node) {\r\n            fix_node = cut_node.left;\r\n        }\r\n        else {\r\n            fix_node = cut_node.right;\r\n        }\r\n\r\n        // remove cut_node from parent\r\n        /*if (fix_node != nil_node) {*/\r\n            fix_node.parent = cut_node.parent;\r\n        /*}*/\r\n\r\n        if (cut_node == this.root) {\r\n            this.root = fix_node;\r\n        }\r\n        else {\r\n            if (cut_node == cut_node.parent.left) {\r\n                cut_node.parent.left = fix_node;\r\n            }\r\n            else {\r\n                cut_node.parent.right = fix_node;\r\n            }\r\n            cut_node.parent.update_max();        // update max property of the parent\r\n        }\r\n\r\n        this.recalc_max(fix_node);              // update max property upward from fix_node to root\r\n\r\n        // COPY DATA !!!\r\n        // Delete_node becomes cut_node, it means that we cannot hold reference\r\n        // to node in outer structure and we will have to delete by key, additional search need\r\n        if (cut_node != delete_node) {\r\n            delete_node.copy_data(cut_node);\r\n            delete_node.update_max();           // update max property of the cut node at the new place\r\n            this.recalc_max(delete_node);       // update max property upward from delete_node to root\r\n        }\r\n\r\n        if (/*fix_node != nil_node && */cut_node.color == RB_TREE_COLOR_BLACK) {\r\n            this.delete_fixup(fix_node);\r\n        }\r\n    }\r\n\r\n    delete_fixup(fix_node) {\r\n        let current_node = fix_node;\r\n        let brother_node;\r\n\r\n        while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {\r\n            if (current_node == current_node.parent.left) {          // fix node is left child\r\n                brother_node = current_node.parent.right;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_left(current_node.parent);\r\n                    brother_node = current_node.parent.right;                      // update brother\r\n                }\r\n                // Derive to cases 2..4: brother is black\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {  // case 2: both nephews black\r\n                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother\r\n                    current_node = current_node.parent;                  // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother\r\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew\r\n                        this.rotate_right(brother_node);\r\n                        brother_node = current_node.parent.right;                     // update brother\r\n                        // Derive to case 4: left nephew black, right nephew red\r\n                    }\r\n                    // case 4: left nephew black, right nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_left(current_node.parent);\r\n                    current_node = this.root;                         // exit from loop\r\n                }\r\n            }\r\n            else {                                             // fix node is right child\r\n                brother_node = current_node.parent.left;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_right(current_node.parent);\r\n                    brother_node = current_node.parent.left;                        // update brother\r\n                }\r\n                // Go to cases 2..4\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 2\r\n                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother\r\n                    current_node = current_node.parent;                              // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.left.color == RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother\r\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew\r\n                        this.rotate_left(brother_node);\r\n                        brother_node = current_node.parent.left;                        // update brother\r\n                        // Derive to case 4: right nephew black, left nephew red\r\n                    }\r\n                    // case 4: right nephew black, left nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_right(current_node.parent);\r\n                    current_node = this.root;                               // force exit from loop\r\n                }\r\n            }\r\n        }\r\n\r\n        current_node.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_search(node, search_node) {\r\n        if (node == null || node == nil_node)\r\n            return undefined;\r\n\r\n        if (search_node.equal_to(node)) {\r\n            return node;\r\n        }\r\n        if (search_node.less_than(node)) {\r\n            return this.tree_search(node.left, search_node);\r\n        }\r\n        else {\r\n            return this.tree_search(node.right, search_node);\r\n        }\r\n    }\r\n\r\n    // Original search_interval method; container res support push() insertion\r\n    // Search all intervals intersecting given one\r\n    tree_search_interval(node, search_node, res) {\r\n        if (node != null && node != nil_node) {\r\n            // if (node->left != nil_node && node->left->max >= low) {\r\n            if (node.left != nil_node && !node.not_intersect_left_subtree(search_node)) {\r\n                this.tree_search_interval(node.left, search_node, res);\r\n            }\r\n            // if (low <= node->high && node->low <= high) {\r\n            if (node.intersect(search_node)) {\r\n                res.push(node);\r\n            }\r\n            // if (node->right != nil_node && node->low <= high) {\r\n            if (node.right != nil_node && !node.not_intersect_right_subtree(search_node)) {\r\n                this.tree_search_interval(node.right, search_node, res);\r\n            }\r\n        }\r\n    }\r\n\r\n    local_minimum(node) {\r\n        let node_min = node;\r\n        while (node_min.left != null && node_min.left != nil_node) {\r\n            node_min = node_min.left;\r\n        }\r\n        return node_min;\r\n    }\r\n\r\n    // not in use\r\n    local_maximum(node) {\r\n        let node_max = node;\r\n        while (node_max.right != null && node_max.right != nil_node) {\r\n            node_max = node_max.right;\r\n        }\r\n        return node_max;\r\n    }\r\n\r\n    tree_successor(node) {\r\n        let node_successor;\r\n        let current_node;\r\n        let parent_node;\r\n\r\n        if (node.right != nil_node) {\r\n            node_successor = this.local_minimum(node.right);\r\n        }\r\n        else {\r\n            current_node = node;\r\n            parent_node = node.parent;\r\n            while (parent_node != null && parent_node.right == current_node) {\r\n                current_node = parent_node;\r\n                parent_node = parent_node.parent;\r\n            }\r\n            node_successor = parent_node;\r\n        }\r\n        return node_successor;\r\n    }\r\n\r\n    //           |            right-rotate(T,y)       |\r\n    //           y            ---------------.       x\r\n    //          / \\                                  / \\\r\n    //         x   c          left-rotate(T,x)      a   y\r\n    //        / \\             <---------------         / \\\r\n    //       a   b                                    b   c\r\n\r\n    rotate_left(x) {\r\n        let y = x.right;\r\n\r\n        x.right = y.left;           // b goes to x.right\r\n\r\n        if (y.left != nil_node) {\r\n            y.left.parent = x;     // x becomes parent of b\r\n        }\r\n        y.parent = x.parent;       // move parent\r\n\r\n        if (x == this.root) {\r\n            this.root = y;           // y becomes root\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (x == x.parent.left) {\r\n                x.parent.left = y;\r\n            }\r\n            else {\r\n                x.parent.right = y;\r\n            }\r\n        }\r\n        y.left = x;                 // x becomes left child of y\r\n        x.parent = y;               // and y becomes parent of x\r\n\r\n        if (x != null && x != nil_node) {\r\n            x.update_max();\r\n        }\r\n\r\n        y = x.parent;\r\n        if (y != null && y != nil_node) {\r\n            y.update_max();\r\n        }\r\n    }\r\n\r\n    rotate_right(y) {\r\n        let x = y.left;\r\n\r\n        y.left = x.right;           // b goes to y.left\r\n\r\n        if (x.right != nil_node) {\r\n            x.right.parent = y;        // y becomes parent of b\r\n        }\r\n        x.parent = y.parent;          // move parent\r\n\r\n        if (y == this.root) {        // x becomes root\r\n            this.root = x;\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (y == y.parent.left) {\r\n                y.parent.left = x;\r\n            }\r\n            else {\r\n                y.parent.right = x;\r\n            }\r\n        }\r\n        x.right = y;                 // y becomes right child of x\r\n        y.parent = x;               // and x becomes parent of y\r\n\r\n        if (y != null && y != nil_node) {\r\n            y.update_max();\r\n        }\r\n\r\n        x = y.parent;\r\n        if (x != null && x != nil_node) {\r\n            x.update_max();\r\n        }\r\n    }\r\n\r\n    tree_walk(node, action) {\r\n        if (node != null && node != nil_node) {\r\n            this.tree_walk(node.left, action);\r\n            // arr.push(node.output());\r\n            action(node);\r\n            this.tree_walk(node.right, action);\r\n        }\r\n    }\r\n\r\n    /* Return true if all red nodes have exactly two black child nodes */\r\n    testRedBlackProperty() {\r\n        let res = true;\r\n        this.tree_walk(this.root, function (node) {\r\n            if (node.color == RB_TREE_COLOR_RED) {\r\n                if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {\r\n                    res = false;\r\n                }\r\n            }\r\n        });\r\n        return res;\r\n    }\r\n\r\n    /* Throw error if not every path from root to bottom has same black height */\r\n    testBlackHeightProperty(node) {\r\n        let height = 0;\r\n        let heightLeft = 0;\r\n        let heightRight = 0;\r\n        if (node.color == RB_TREE_COLOR_BLACK) {\r\n            height++;\r\n        }\r\n        if (node.left != nil_node) {\r\n            heightLeft = this.testBlackHeightProperty(node.left);\r\n        }\r\n        else {\r\n            heightLeft = 1;\r\n        }\r\n        if (node.right != nil_node) {\r\n            heightRight = this.testBlackHeightProperty(node.right);\r\n        }\r\n        else {\r\n            heightRight = 1;\r\n        }\r\n        if (heightLeft != heightRight) {\r\n            throw new Error('Red-black height property violated');\r\n        }\r\n        height += heightLeft;\r\n        return height;\r\n    };\r\n};\r\n\r\nmodule.exports = IntervalTree;\r\n","/**\r\n * Created by Alex Bol on 3/28/2017.\r\n */\r\n\r\n'use strict';\r\n\r\nmodule.exports = {\r\n    RB_TREE_COLOR_RED: 0,\r\n    RB_TREE_COLOR_BLACK: 1\r\n};","/**\r\n * Created by Alex Bol on 2/19/2017.\r\n */\r\nmodule.exports = {\r\n    ILLEGAL_PARAMETERS: new ReferenceError('Illegal Parameters'),\r\n    ZERO_DIVISION: new Error('Zero division')\r\n};\r\n\r\n","/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n\r\n/**\r\n * Global constant DP_TOL is used for comparison of floating point numbers.\r\n * It is set to 0.000001.\r\n * @type {number}\r\n */\r\nconst DP_TOL = 0.000001;\r\nconst DECIMALS = 3;\r\n\r\nmodule.exports = {\r\n    DP_TOL: DP_TOL,\r\n    /**\r\n     * Returns *true* if value comparable to zero\r\n     * @return {boolean}\r\n     */\r\n    EQ_0: function(x) {\r\n        return ( (x) < DP_TOL && (x) > -DP_TOL );\r\n    },\r\n    /**\r\n     * Returns *true* if two values are equal up to DP_TOL\r\n     * @return {boolean}\r\n     */\r\n    EQ: function(x,y) {\r\n        return ( (x)-(y) <  DP_TOL && (x)-(y) > -DP_TOL );\r\n    },\r\n    /**\r\n     * Returns *true* if first argument greater than second argument up to DP_TOL\r\n     * @return {boolean}\r\n     */\r\n    GT: (x,y) => {\r\n        return ( (x)-(y) >  DP_TOL );\r\n    },\r\n    /**\r\n     * Returns *true* if first argument greater than or equal to second argument up to DP_TOL\r\n     * @return {boolean}\r\n     */\r\n    GE: (x,y) => {\r\n        return ( (x)-(y) > -DP_TOL );\r\n    },\r\n    /**\r\n     * Returns *true* if first argument less than second argument up to DP_TOL\r\n     * @return {boolean}\r\n     */\r\n    LT: (x,y) => {\r\n        return ( (x)-(y) < -DP_TOL )\r\n    },\r\n    /**\r\n     * Returns *true* if first argument less than or equal to second argument up to DP_TOL\r\n     * @return {boolean}\r\n     */\r\n    LE: (x,y) => {\r\n        return ( (x)-(y) <  DP_TOL );\r\n    }\r\n};\r\n"],"sourceRoot":""}